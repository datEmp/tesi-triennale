\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{import}
\usepackage{graphicx}
\usepackage{float}
\usepackage[margin=1.2in]{geometry}
\usepackage[12pt]{extsizes}
\usepackage{color}
\usepackage{listings}
\usepackage[bottom,flushmargin,hang,multiple]{footmisc}
\usepackage{titlesec}
\usepackage{url}
\usepackage{upquote}
\usepackage{csquotes}
\usepackage{biblatex}
\usepackage{spverbatim}
\usepackage{dirtree}
\usepackage{etoolbox}
\usepackage{midpage}
\usepackage[export]{adjustbox}
\usepackage{svg}
\usepackage{amsmath}
\apptocmd{\dirtree}{\bigskip}{}{}
\pretocmd{\dirtree}{\bigskip}{}{}
\definecolor{purple}{RGB}{91, 72, 181}
\definecolor{darkviolet}{rgb}{0.58, 0.0, 0.83}
\definecolor{royalblue}{RGB}{242, 73, 214}
\definecolor{orange}{RGB}{227, 72, 41}
\definecolor{lightgreen}{RGB}{164, 194, 14}

\definecolor{mediumgray}{rgb}{0.3, 0.4, 0.4}
\definecolor{forestgreen}{rgb}{0.13, 0.55, 0.13}
\definecolor{crimson}{rgb}{0.86, 0.8, 0.24}

\addbibresource{./bibliografia/bibliografia.bib}

\graphicspath{ {./images/} }

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}

\titleformat{\paragraph}{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\lstset{aboveskip=30pt,belowskip=30pt}

\lstdefinestyle{JSES6Base}{
  backgroundcolor=\color{white},
  basicstyle=\linespread{1.2}\ttfamily\footnotesize,
  breakatwhitespace=false,
  breaklines=true,
  captionpos=b,
  columns=fullflexible,
  commentstyle=\color{mediumgray}\upshape,
  emph={},
  emphstyle=\color{crimson},
  extendedchars=true,  % requires inputenc
  fontadjust=true,
  frame=single,
  identifierstyle=\color{black},
  keepspaces=true,
  keywordstyle=\color{purple},
  keywordstyle={[2]\color{darkviolet}},
  keywordstyle={[3]\color{royalblue}},
  keywordstyle={[4]\color{orange}},
  keywordstyle={[5]\color{lightgreen}},
  numbers=left,
  numbersep=5pt,
  numberstyle=\tiny\color{black},
  rulecolor=\color{black},
  showlines=true,
  showspaces=false,
  showstringspaces=false,
  showtabs=false,
  stringstyle=\color{forestgreen},
  tabsize=2,
  title=\lstname,
  upquote=true  % requires textcomp
}

\lstdefinestyle{JavaScript}{
  language=JavaScript,
  style=JSES6Base
}

\lstdefinestyle{ES6}{
  language=ES6,
  style=JSES6Base
}

\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{break, continue, delete, else, for, function, if, in,
    new, return, this, typeof, var, void, while, with, render, getElementById, width, height, contract, address, event, uint256, public, returns, emit, pragma, describe, it},
  % Literals, primitive types, and reference types.
  morekeywords=[2]{false, null, true, boolean, number, undefined,
    Array, Boolean, Date, Math, Number, String, Object, onClick, Map, onChange, SMART_CONTRACTS, TKN_TMPLT_ABI, SALE_FCTRY_ADDR, SALE_FCTRY_ABI},
  morekeywords=[3]{h1, div, p, button, TextField},
  morekeywords=[4]{React, ., Component, Saluto, Convenevoli, Contatore, setContatore, useState, contatore,
    Button, ContatoreConTitolo, handleSearch, searchInput, target, value, setActiveCoinsList, coinsList, coinName, coinSymbol, coin,
    coinsToSellAmounts, setCoinsToSellAmounts, coinsToAcceptAmounts, setCoinsToAcceptAmounts, setCoinsList, activeCoinsList,
    activeStep, setActiveStep, web3Instance, userAccount, fetchCoins, setLoadingCoinList, newCoinsList, Contratto, saleCreate, web3,
    sellerAddress, coinsOnSaleAddr, amountsOnSale, coinsToAcceptAddr, amountsToAccept, expirationDate, coinInstance, SaleFactoryInstance, creationResponse, saleAddr,
    handleAcceptSale, handleCancelSale, changeShowingSales, handleSalesStatusSelection, handleChangeFilter, acceptRefund, calcRefund, fetchSales, createSale,
    showCoinError, handleAmountChange, saleCancelBatch, saleCancel, saleAccept, saleGetAll, assertFailError, setupContracts, tokensOnSaleAddr, tokensToAcceptAddr,
    expiration, seller, buyer, tokenOnSaleOne, tokenOnSaleTwo, tokenToAcceptOne, tokenToAcceptTwo, getTokensOnSaleAddr, getTokensToAcceptAddr, getSaleExpiration, getSaleOwner, getSaleInfo,
    owner, saleEnded, retAmountsOnSale, retAmountsToAccept, exp, cancelSale, acceptSale, constructor, cancelBatchSales, getPossesedSalesAddresses, getAllSalesAddresses, EsempioContratto, },
  morekeywords=[5]{},
  sensitive,
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morecomment=[s]{/**}{*/}, % JavaDoc style comments
  morestring=[b]',
  morestring=[b]"
}[keywords, comments, strings]

\lstalias[]{ES6}[ECMAScript2015]{JavaScript}

\lstdefinelanguage[ECMAScript2015]{JavaScript}[]{JavaScript}{
  morekeywords=[1]{await, async, case, catch, class, const, default, do,
    enum, export, extends, finally, from, implements, import, instanceof,
    let, static, super, switch, throw, try},
  morestring=[b]` % Interpolation strings.
}


\title{Progettazione e realizzazione di un exchange decentralizzato per lo scambio di token ERC20 per la piattaforma CommonsHood}
\linespread{1.5}
\begin{document}
    \import{/home/shaohao/Projects/tesi/Tesi/frontespizio/}{Frontespizio.tex}
    \restoregeometry

    \section*{Abstract}
      CommonsHood è un’applicazione web basata su smart contract per blockchain Ethereum che ha lo scopo di fornire alla comunità strumenti per l’inclusione finanziaria e per supportare l’economia locale delle comunità di cittadini.
      L’applicazione permette agli utenti di creare nuovi tipi di token crittografici che possono rappresentare  beni di valore o servizi. Tali token, quindi, possono essere utilizzati per creare campagne di crowdfunding, coupons e per altre funzionalità incluse all’interno di CommonsHood. È perciò necessario permettere agli utenti la compravendita e lo scambio dei token creati e distribuiti.
      Lo scopo principale di questa tesi è l’implementazione delle funzionalità di vendita e acquisto dei token crittografici attraverso la progettazione e realizzazione di un exchange decentralizzato.
      Nella fase iniziale, attraverso l’uso del linguaggio Solidity, sono stati scritti gli smart contracts che definiscono le regole e il funzionamento delle compravendite (gestite attraverso il meccanismo di domanda e offerta), e, con l’uso del linguaggio Javascript, sono stati realizzati i test che ne verificano il corretto funzionamento.
      Nella fase successiva è stata creata l’interfaccia web che permette l’utilizzo delle funzioni di compravendita. Questa è stata realizzata ancora tramite il linguaggio Javascript ed utilizzando il framework ReactJS e i componenti grafici inclusi nel framework Material-UI. Per collegare l’applicazione con la blockchain è stato utilizzato il framework web3.js.

    \newpage
    \tableofcontents
    \newpage
    \begin{midpage}
      \textit{``Dichiaro  di  essere  responsabile  del  contenuto  dell'elaborato  che  presento  al 
      fine  del  conseguimento  del  titolo,  di  non  avere  plagiato  in  tutto  o  in  parte  il 
      lavoro prodotto da altri e di aver citato le fonti originali in modo congruente alle 
      normative  vigenti  in  materia  di  plagio  e  di  diritto  d'autore.  Sono  inoltre 
      consapevole  che  nel  caso  la  mia  dichiarazione  risultasse  mendace,  potrei 
      incorrere  nelle  sanzioni  previste  dalla  legge  e  la  mia  ammissione  alla  prova 
      finale potrebbe essere negata.''}
    \end{midpage}
    \section{Introduzione}
    \subsection{CommonsHood}
    CommonsHood è un’applicazione web basata su smart contract per blockchain Ethereum che ha lo scopo di fornire alla comunità strumenti per l’inclusione finanziaria e per supportare l’economia locale delle comunità di cittadini.
    Gli utenti, una volta registrati sulla piattaforma, possono creare monete, ossia token crittografici Ethereum basati sullo standard ERC-20, questi possono rappresentare beni di valore o servizi.
    \newline
    Un'altra funzionalità offerta dall'applicazione è la possibilità di creare crowdsales, questi sono usati per ottenere fondi per finanziare progetti o eventi, dando, in cambio, ai finanziatori monete oppure coupons.
    Un esempio di un'interazione con la piattaforma potrebbe essere: il negozio di attrezzature da sub \emph{"Sotto il Mar"} crea un account su CommonsHood. Crea, inoltre, una moneta chiamata \emph{"Doblone"}, questa può essere spesa in negozio
    per acquistare le attrezzature. Oltre alla vendita, il negozio noleggia anche le attrezzature, perciò crea dei coupon che possono essere utilizzati per ottenere i prodotti a noleggio.
    Inoltre, una stanza ha bisogno di ristrutturazioni perciò viene creata una crowdsale per ottenere il finanziamento necessario, in cambio vengono offerti dei coupon del negozio.
    
    \subsection{Blockchain}
    Una blockchain è un registro aperto e distribuito di dati, strutturato come una catena di blocchi contenenti le transazioni.
    Le transazioni solitamente rappresentano uno scambio di monete, chiamate token. Ogni blockchain ha un token proprio.
    I dati risiedono su unità computazionali chiamati \emph{nodi}, questi, come mostrato nell'immagine \ref{fig:node},
    sono interconnessi e comunicano tra loro per mantenere i dati di tutti i nodi aggiornati\cite{nodo}.
    Un account su una blockchain è costituito da una coppia di chiavi:
    \begin{itemize}
      \item pubblica: è un indirizzo sulla blockchain, i token nella rete sono registrati come appartenenti ad un indirizzo;
      \item privata: rappresenta la password che l'utente utilizza per accedere ai propri fondi.
    \end{itemize}
    \begin{figure}[ht]
      \includegraphics[scale=0.8, fbox]{node.png}
      \centering
      \caption{Rete di nodi}
      \centering
      \label{fig:node}
    \end{figure}
    \subsubsection{I nodi}
    Le responsabilità di un nodo sono principalmente:
    \begin{itemize}
      \item Controllo della validità di un nuovo record di dati, chiamato anche transazione, e accettarlo o rifiutarlo;
      \item Nel caso di un record valido, salvataggio della transazione nel registro locale del nodo;
      \item Comunicazione e distribuzione della transazione agli altri nodi. In questo modo tutti i nodi hanno la stessa versione del registro.
    \end{itemize}
    \subsubsection{Le caratteristiche di una blockchain}
    Le caratteristiche principali della tecnologia blockchain sono:
    \begin{itemize}
      \item Decentralizzazione: le informazioni contenute nel registro digitale vengono distribuite tra più nodi, così da garantire sicurezza e resilienza dei sistemi anche in caso di attacco a uno dei nodi o in caso di perdita di un nodo.
      \item Tracciabilità: ogni elemento salvato nel registro è tracciabile in ogni sua parte e se ne può risalire all’esatta provenienza e alle eventuali modifiche apportate nel corso del tempo, con una precisione assoluta.
      \item Disintermediazione: i singoli nodi della blockchain certificano le informazioni distribuite, rendendo quindi del tutto inutile la presenza di enti centrali o di aziende per la certificazione dei dati.
      \item Trasparenza: il contenuto del registro è visibile a tutti ed è facilmente consultabile e verificabile da ogni nodo della rete ma anche tramite servizi che interrogano la blockchain senza apportare modifiche. Nessuno può nascondere o modificare dati senza che l'intera rete venga a saperlo.
      \item Solidità del registro: dopo aver aggiunto un'informazione al registro, essa non può essere modificata senza il consenso di tutta la rete.
      \item Programmabilità: le operazioni di transazione possono anche essere programmate nel tempo, così da poter attendere il verificarsi di determinate condizioni prima di procedere con l'inserimento o la modifica\cite{blockchain1}.
    \end{itemize}
    \subsubsection{Struttura e funzionamento di una blockchain}
    \label{blockchainFunc}
    \begin{figure}[ht]
      \includegraphics[scale=0.7, fbox]{blockchain.drawio.png}
      \centering
      \caption{Struttura a catena di una blockchain}
      \centering
      \label{fig:blockchainStruct}
    \end{figure}
    Una blockchain, come dice anche il nome, è una catena di blocchi. Un blocco è un insieme di transazioni ed è collegato ad un altro blocco grazie al concetto di "\emph{One-way hash function}".
    Una \emph{one-way hash function} è una funzione che, passando in input dei dati, restituisce in output una stringa univoca di dimensione fissa chiamata "\emph{hash}". Questo significa che, cambiando anche
    solo leggermente i dati in input, l'hash risultante cambia completamente. E' \emph{one-way} perché avendo un hash è molto difficile o quasi impossibile ottenere il messaggio originale.
    Ogni blocco, quindi, contiene al suo interno l'hash del blocco precedente, e questa informazione è chiamata "\emph{PrevHash}". L'unico blocco all'interno di una blockchain a non avere la PrevHash è il primo blocco,
    questo è chiamato anche "\emph{blocco di genesi}". Questi collegamenti tra i blocchi determinano, quindi, la struttura a catena della blockchain. Siccome la blockchain è decentralizzata, ogni nodo della rete ha una copia
    della catena. Prima che una transazione venga aggiunta a un blocco, questa deve essere verificata. Quando un utente genera una transazione applica alla transazione una firma. Quest'ultima è un hash generato dall'uso di una funzione di hash sul messaggio della transazione e la chiave privata dell'utente.
    Per verificare l'autenticità della transazione, ossia che sia stato effettivamente un particolare utente a generare la transazione, viene usata una funzione che, dati in input il messaggio della transazione, la firma della transazione e la chiave pubblica dell'utente, restituisce \verb|true| se la chiave pubblica
    è quella associata alla chiave privata che ha generato la firma, \verb|false| altrimenti. Una volta verificata la transazione, questa può essere aggiunta al nuovo blocco.

    \subsubsection{Meccanismo di consenso}
    Come detto nella sezione \ref{blockchainFunc}, ogni nodo della blockchain ha una copia personale della struttura e dei dati contenuti. Un nodo ha il compito di aggiungere nuovi blocchi alla sua catena e comunicare il cambiamento agli altri nodi, questi aggiungeranno il nuovo blocco anche alla loro copia.
    Si vuole evitare, però, che un nodo malintenzionato possa aggiungere transazioni false alla sua catena e comunicarlo al resto della rete.
    Sorge, perciò, un grande problema: come capire quale copia di blockchain è quella veritiera? Ovvero è necessario un sistema che, date due copie di blockchain, capisca quale sia quella vera. Questo è un problema del consenso e si riconduce al "\emph{problema dei generali bizantini}".
    Esistono diversi approcci a questo problema, tra cui due sono le principali soluzioni adottate dalle diverse reti blockchain:
    \begin{itemize}
      \item \emph{Proof-of-Work} (o PoW);
      \item \emph{Proof-of-Stake} (o PoS).
    \end{itemize}
    \paragraph{Proof-of-Work}
    Nella \emph{Proof-of-Work} la prova di veridicità è determinata dalla quantità di lavoro computazionale svolto. Un nodo, quando costruisce un blocco e deve validarlo, deve trovare e inserire nel blocco un numero chiamato "\emph{nonce}".
    Questo lavoro è complicato perché si deve trovare un \emph{nonce} per cui l'hash del blocco inizi con una sequenza di zeri di una certa lunghezza determinata. Una volta che il nodo trova questo valore, il blocco è considerato verificato e viene trasmesso agli altri nodi che lo accetteranno come blocco successivo nella loro catena.
    Questo processo di validazione dei blocchi è anche chiamato "\emph{mining}" e i nodi vengono chiamati "\emph{miner}".
    In caso i nodi ricevano due blocchi contrastanti, ovvero puntano allo stesso blocco precedente, si crea una biforcazione e i miner continuano a validare i blocchi su entrambi i rami e, quindi, a estendere le biforcazioni. Quando una delle biforcazioni
    diventa più lunga, questa viene considerata la versione della blockchain corretta. Ovvero la biforcazione con più lavoro computazionale svolto viene considerata veritiera. 
    Un ipotetico malintenzionato che vuole aggiungere un blocco falso dovrebbe riuscire a validare i blocchi più velocemente del resto dell'intera rete per riuscire a mantenere la biforcazione, creata a partire dal suo blocco, la più lunga. Questo richiede una insostenibile potenza computazionale che difficilmente una singola entità possiede.
    Per riuscire ad attaccare con successo una rete che adotta la PoW, l'attaccante dovrebbe possedere almeno il 51\% della potenza computazionale dell'intera blockchain e questo è molto difficile che accada.
    \paragraph{Proof-of-Stake}
    In un sistema basato sull'approccio \emph{Proof-of-Stake} viene selezionato un nodo casuale per validare il prossimo blocco. Un nodo, per poter partecipare all'operazione di validazione di blocchi, deve bloccare nella rete un certo quantitativo di criptovalute della blockchain. Questa quota bloccata è chiamata anche "\emph{stake}" e il nodo
    non può spendere queste monete finché sono bloccate. Maggiore è la quota bloccata e maggiore è la probabilità del nodo di essere selezionato come prossimo validatore. Una volta verificate le transazioni all'interno del blocco, questo verrà firmato dal nodo e aggiunto alla blockchain. A questo punto
    il nodo validatore riceve una "\emph{transaction fee}", ossia una piccola tassa dalle transazioni validate come ricompensa per il lavoro svolto. I nodi che partecipano a questo processo sono anche chiamati "\emph{forger}". Quando un nodo vuole smettere di essere un forger, il suo stake e le ricompense guadagnate verranno sbloccate dopo un certo periodo di tempo, permettendo
    alla rete di verificare che il nodo non abbia aggiunto blocchi fraudolenti alla blockchain. In caso la rete rilevi transazioni fraudolente, il nodo forger perderà una parte del suo stake, le ricompense guadagnate e la possibilità di partecipare come forger in futuro. In questo modo i nodi forger sono incentivati a non creare o validare blocchi fraudolenti.
    Per attaccare una rete di questo tipo, l'attaccante dovrebbe possedere almeno il 51\% delle criptovalute della blockchain e questo è altamente dispendioso e complicato.

    \subsubsection{Smart contracts}
    Le blockchain permettono d'implementare codici e funzioni all'interno di esse, questi sono chiamati smart contracts e permettono l'esecuzione di operazioni quando predeterminate condizioni si avverano.
    Sono tipicamente usate per automatizzare l'esecuzione di un accordo, in questo modo tutti i partecipanti possono verificarne immediatamente i risultati, senza aver bisogno di un intermediario.
    Possono, inoltre, essere utilizzate per automatizzare workflow, innescando azioni successive al raggiungimento di certe condizioni\cite{smartcontracts}.
    
    \subsection{Ethereum}
    Ethereum è una piattaforma blockchain decentralizzata che stabilisce una rete peer-to-peer che esegue e verifica smart contracts in modo sicuro.
    Gli smart contracts permettono transazioni tra gli utenti senza la necessità di un autorità centrale.
    Le transazioni sono immutabili, verificabili, e distribuiti in modo sicuro sulla rete. Le transazioni sono inviate e ricevute da account Ethereum creati dagli utenti.
    Come costo per il processamento di una transazione sulla rete, l'utente deve spendere Ether (ETH), la criptovaluta nativa di Ethereum\cite{ethereum}.
    \subsubsection{Token Ethereum}
    Ethereum permette la creazione di token crittografici all'interno della sua rete. Questi token non sono altro che smart contracts scritti seguendo specificazioni stabilite
    dagli sviluppatori della rete. I token possono essere di tipi di differenti, a seconda delle specificazioni seguite. In Ethereum ci sono principalmente due tipi di token: token ERC-20 e NFT.
    \paragraph{Token ERC-20}
    I token ERC-20 sono il tipo di token più diffuso sulla rete Ethereum, sono lo standard per la definizione di token fungibili\cite{erc20}, ossia i singoli token sono indistinguibili e intercambiabili tra loro.
    Un token ERC-20 implementa le specificazioni indicate nell'EIP-20\footnote{Ethereum Improvement Proposal} che richiede nello smart contract del token la presenza di diversi metodi. I più importanti metodi richiesti sono:
    \begin{itemize}
      \item \verb|balanceOf(address _owner)|: restituisce la quantità di token posseduto da \verb|_owner|;
      \item \verb|transfer(address _to, uint256 _value)|: trasferisce una quantità di token indicata da \verb|_value| all'indirizzo \verb|_to|;
      \item \verb|transferFrom(address _from, address _to, uint256 _value)|:\newline trasferisce una quantità \verb|_value| di token dall'indirizzo \verb|_from| all'indirizzo \verb|_to|;
      \item \verb|approve(address _spender, uint256 _value)|: permette all'indirizzo \verb|_spender|, usando la funzione \verb|transferFrom()|, di spendere fino a \verb|_value| token dall'account\cite{eip20}. Un esempio di utilizzo di questa funzione potrebbe essere:
            l'account A chiama la funzione \verb|approve()| passando come parametri l'indirizzo di account B e 100. L'account B potrà, quindi, spendere dal saldo di account A fino a 100 unità della moneta su cui è stata chiamata \verb|approve()|.
    \end{itemize}

    \paragraph{NFT}
    I Non Fungible Tokens sono, appunto, token non fungibili, ossia ogni token è univoco e non intercambiabile con un altro. Sono utilizzati per replicare le proprietà tipiche
    di un oggetto fisico come la scarsità, l'unicità e la possibilità di dimostrare la proprietà del token\cite{nft}.
    Data la natura del token, l'uso più comune di questi token è la creazione di arte digitale\cite{nftuse}.
    \newline
    Gli NFT seguono lo standard dettato dall'EIP-721. I metodi più significativi richiesti dall'EIP-721 sono:
    \begin{itemize}
      \item \verb|balanceOf(address _owner)|: restituisce il numero di NFT posseduti da \verb|_owner|;
      \item \verb|ownerOf(uint256 _tokenId)|: restituisce il proprietario del NFT identificato da \verb|_tokenId|;
      \item \verb|safeTransferFrom(address _from,address _to,uint256 _tokenId)|: trasferisce la proprietà del NFT \verb|_tokenId| da \verb|_from| a \verb|_to|.
            Fallisce se il chiamante della funzione non è il proprietario corrente, un operatore autorizzato o un indirizzo autorizzato per questo NFT.
            Inoltre, il metodo fallisce se: \verb|_from| non è il proprietario corrente, \verb|_to| è l'indirizzo zero e \verb|_tokenId| non è un NFT valido\cite{eip1155}.
            Un esempio di uso potrebbe essere: l'account A possiede l'NFT con id 130, chiamando la funzione \verb|safeTransferFrom()| con parametri l'indirizzo di account B e l'id della NFT, il possesso del token passerebbe a quest'ultimo account.
    \end{itemize}
    \subsubsection{Smart contracts in Ethereum}
    In Ethereum gli smart contracts sono considerati come account, questo significa che hanno un saldo e possono inviare transazioni sulla rete. A differenza di un normale account, però,
    gli smart contracts non sono controllati dagli utenti ma eseguono il codice con cui sono stati programmati. Gli account user possono interagire con uno smart contract inviando una transazione
    che effettua una chiamata a una funzione definita nello smart contract. Di default questi contratti non possono essere eliminati e le interazioni con essi sono irreversibili.
    \newline
    Il codice di uno smart contract si scrive utilizzando \emph{Solidity}, un linguaggio object-oriented usato per implementare smart contracts su diverse piattaforme blockchain.
    Di seguito un esempio di uno smart contract semplice:
    \begin{lstlisting}[style=ES6, title={Esempio codice di uno smart contract}]
      pragma solidity ^0.5.2;

      contract EsempioContratto() {
        address public owner;
        
        event EsempioEvento(
          uint256 parametroEvento
        )

        function esempioFunzione(
          uint256 _parametro
        ) public returns (uint256) {
          emit EsempioEvento(_parametro)
          return _parametro
        }
      }\end{lstlisting}
      Solitamente uno smart contract inizia con la dichiarazione della versione di solidity usata per la scrittura del codice, in questo modo il compilatore, se di versione superiore, rifiuta la compilazione del codice.
      Per far questo si scrive: \newline \verb|pragma solidity [versione]|. Nell'esempio precedente la versione è dichiarata nella prima riga, in questo caso la versione indicata è superiore a 0.5.2.
      \newline
      Una volta dichiarata la versione, inizia il codice dello smart contract, questo viene indicato con \verb|contract [nome contratto]()|. Prendendo sempre come riferimento l'esempio precedente,
      alla riga 4 viene dichiarata una variabile chiamata owner con visibilità \verb|public| e tipo \verb|address|, ossia un indirizzo Ethereum. Ci sono 4 livelli di visibilità per le variabili e le funzioni:
      \begin{itemize}
        \item \verb|public|: le funzioni possono essere chiamate anche da contratti esterni, per le variabili vengono generate in automatico delle funzioni getter implicite;
        \item \verb|external|: le funzioni e le variabili possono essere accedute solo dall'esterno e non internamente nel contratto;
        \item \verb|internal|: le funzioni e le variabili possono essere accedute dentro il contratto stesso e i contratti derivati;
        \item \verb|private|: visibili solo nel contratto in cui le variabili e le funzioni sono definite\cite{solidityvisibility}.
      \end{itemize}
      Solidity fornisce numerosi tipi per le variabili, di cui quelle usate in questa tesi sono:
      \begin{itemize}
        \item \verb|bool|: per indicare una variabile booleana;
        \item \verb|uint|: per indicare un intero senza segno, può avere diverse dimensioni aggiungendo il numero di bits, ad esempio \verb|uint256|;
        \item \verb|address|: per indicare un indirizzo Ethereum;
        \item \verb|mapping|: per indicare un dizionario con chiavi di ricerca e valori associati\cite{soliditytypes}.
      \end{itemize}
      Alla riga 6 è stato dichiarato un evento, ossia uno strumento utile per fare logging delle transazioni e per permettere agli utenti di mettersi in ascolto di questi eventi.
      Un evento può contenere dati aggiuntivi, in questo caso l'evento \verb|EsempioEvento| contiene il dato \verb|parametroEvento| di tipo uint256.
      Per emettere un evento si utilizza \verb|emit [nome evento](dati evento)|, come mostrato alla riga 13.
      \newline
      Alla riga 10 è stata dichiarata una funzione di nome \verb|esempioFunzione|, con visibilità \verb|public|, con parametro \verb|_parametro| e che restituisce un valore di tipo \verb|uint256|.
      Questa funzione esegue solo due operazioni: emette l'evento \verb|EsempioEvento| e restituisce un valore. 
    \subsubsection{Ethereum Virtual Machine e gas fees}
    La \emph{Ethereum Virtual Machine}, o EVM, è una macchina virtuale decentralizzata che fa parte dell'ecosistema Ethereum. E' decentralizzata perché tutti i nodi partecipano e mantengono la EVM.
    La EVM permette il deploy e l'esecuzione degli smart contracts. Siccome questi sono scritti in Solidity, un linguaggio ad alto livello, i contratti devono prima essere convertiti a bytecode. A questo punto
    la EVM può eseguire le operazioni di uno smart contract. Per evitare che malintenzionati possano effettuare attacchi di tipo spam sulla rete, è presente il concetto di "\emph{gas fees}", ossia una "tassa"
    che gli utenti devono pagare ai nodi per far eseguire una transazione. Questa tassa è pagata in Ether. Quindi, siccome ogni operazione eseguita su Ethereum ha un costo, un eventuale attacco spam contro la rete risulterebbe
    troppo costosa. Oltre alla funzione di proteggere la rete, le \emph{gas fees} rappresentano anche un incentivo perché, verificando una transazione, i nodi riceverebbero una ricompensa.

    \subsection{OpenZeppelin}
    OpenZeppelin è una libreria per lo sviluppo di smart contracts sicuri. Le principali funzionalità fornite da OpenZeppelin sono:
    \begin{itemize}
    \item Implementazione dei diversi standard dei token Ethereum;
    \item Gestione del controllo degli accessi agli smart contracts;
    \item Componenti Solidity riutilizzabili per creare smart contracts\cite{openzeppelin}.
    \end{itemize}
    Questa libreria è stata utilizzata perché il sistema costruito in questa tesi permette lo scambio di token ERC-20, e queste implementano le interfacce fornite da \emph{OpenZeppelin}.
    Perciò, per lo sviluppo degli smart contract che implementano lo scambio, sono state utilizzate funzioni fornite dalla libreria.

    \subsection{Metamask}
    Metamask è un'estensione del web browser. Questo software permette di connettere il browser con
    applicazioni decentralizzate basate sulla piattaforma Ethereum. Metamask permette la gestione di
    wallet, ossia l'insieme dei token di un utente, Ethereum, la ricezione e l'invio di criptomonete basate su Ethereum, e l'interazione con
    applicazioni decentralizzate. L'estensione, inoltre, fornisce le API Ethereum web3, in questo
    modo le applicazioni sono in grado di leggere dati sulla blockchain\cite{metamask}.

    \subsection{ReactJS}
    React è una libreria JavaScript open-source per lo sviluppo d'interfacce utente.
    \subsubsection{Caratteristiche di ReactJS}
    React fornisce numerosi strumenti che facilitano lo sviluppo di un'interfaccia grafica. Di seguito sono descritti quelli utilizzati in questa tesi.
    \paragraph{Componenti}
    I Componenti permettono di suddividere la UI in parti indipendenti, riutilizzabili e di pensare a ognuna di esse in modo isolato.
    Per definire un componente è necessario implementare una funzione JavaScript, ad esempio:

    \begin{lstlisting}[style=ES6, title={Esempio componente}]
        function Saluto(props) {
            return <h1>Ciao, {props.nome}</h1>;
        }\end{lstlisting}

    Questo componente accetta un oggetto parametro contenente dati sotto forma di una singola
    "props", il quale è un oggetto parametro avente dati al suo interno.
    Per renderizzare un componente bisogna utilizzare la funzione \verb|ReactDOM.render()|,
    passandole come parametri il componente da visualizzare e il riferimento al componente padre.
    Se si volesse, quindi, renderizzare il componente \verb|Saluto|, passando "\emph{Martina}" come parametro \verb|nome|, il codice potrebbe essere:
    
    \begin{lstlisting}[style=ES6, title={Esempio composizione di componenti}]
      ReactDOM.render(
        <Saluto nome="Martina"/>, 
        document.getElementById('root')
      );\end{lstlisting}
    
    I componenti, inoltre, possono essere composte da altri componenti. In questo caso,
    renderizzando il componente padre, verranno visualizzati anche i componenti figli. Ad esempio, 
    si potrebbe avere un componente \verb|Convenevoli| che contiene multipli componenti \verb|Saluto|:
    \begin{lstlisting}[style=ES6, title={Esempio renderizzazione componente}]
      function Convenevoli() {
        return (
          <div>
            <Saluto nome="Sara" />
            <Saluto nome="Cahal" />
            <Saluto nome="Edite" />
          </div>
        );
      }\end{lstlisting}

      \paragraph{Hook state}
      Un componente React di default è stateless. Usando la funzione \verb|useState()| si può
      aggiungere uno stato interno a un componente, React preserverà questo stato tra le ri-renderizzazioni.
      \verb|useState| ritorna una coppia: il valore dello stato corrente e una funzione che ci permette di aggiornarlo.
      La funzione ha un unico parametro ed è il suo stato iniziale. Ad esempio, se si volesse realizzare un contatore con un bottone che, alla sua pressione,
      aumenti il valore del contatore, si potrebbe scrivere il seguente codice:
      \begin{lstlisting}[style=ES6, title={Esempio contatore con stato interno}]
        function Contatore() {
          const [contatore, setContatore] = useState(0);
          return (
            <div>
              <p>Hai cliccato {contatore} volte</p>
              <button 
                onClick={() => setContatore(contatore + 1)}>
                Cliccami
              </button>
            </div>
          );
        }\end{lstlisting}

      \paragraph{Hook effect}
      Il costrutto \verb|useEffect()| permette l'esecuzione di funzioni a ogni renderizzazione da parte di React.
      Questa funzione viene utilizzata per effettuare operazioni nei vari stati del ciclo di vita di un componente.
      \newline
      Nel seguente esempio il titolo del documento viene aggiornato all'aumentare del valore del contatore, infatti, 
      a ogni aggiornamento del DOM da parte di React, viene chiamata la funzione passata a \verb|useEffect()|.
      \begin{lstlisting}[style=ES6, title={Esempio uso di useEffect()}]
        function ContatoreConTitolo() {
          const [contatore, setContatore] = useState(0);

          useEffect(() => {
            document.title = `Hai cliccato ${contatore} volte`;
          });

          return (
            <div>
              <p>Hai cliccato {contatore} volte</p>
              <button
                onClick={() => setContatore(contatore + 1)}>
                Cliccami
              </button>
            </div>
          );
        }\end{lstlisting}

        \subsection{Material-UI}
        Material-UI è una libreria per ReactJS per creare interfacce utente.
        La libreria contiene al suo interno numerosi componenti grafici,
        questi sono forniti di un tema di default, per modificare l'aspetto di
        un componente si può utilizzare la sua proprietà \verb|className|.
        \newline
        Nell'esempio seguente, preso da \cite{materialui}, vengono modificati le dimensione di un componente \verb|<Button>|:
        \begin{lstlisting}[style=ES6, title={Esempio modifica aspetto di un componente}]
          .Button {
            width: "100px",
            height: "100px"
          }

          <Button className="Button">\end{lstlisting}

        \subsection{Truffle e Ganache}
        Truffle e Ganache sono entrambi strumenti contenuti all'interno della suite software Truffle.
        Ganache permette la creazione di una blockchain Ethereum che viene eseguita in locale, semplificando, così,
        il deploy e il test degli smart contracts. Truffle è un software che facilita lo sviluppo di smart contracts.
        \newline
        I principali comandi di truffle utilizzati sono stati:
        \begin{itemize}
          \item \verb|truffle compile|, per compilare gli smart contracts;
          \item \verb|truffle test|, per eseguire i file di test;
          \item \verb|truffle deploy|\footnote{oppure truffle migrate}, per eseguire il deploy degli smart contracts\cite{truffle}.
        \end{itemize}
        \subsubsection{Creazione di un progetto Truffle}
        Per creare un progetto con Truffle si utilizza il comando \verb|truffle init| all'interno della sua cartella. Questo genera la struttura del progetto composta da quattro elementi:
        \begin{itemize}
          \item \verb|contracts/|: la cartella che conterrà gli smart contracts;
          \item \verb|migrations/|: la cartella che conterrà gli scripts per il deploy dei contratti;
          \item \verb|test/|: la cartella che conterrà i file per eseguire i test sui contratti;
          \item \verb|truffle-config.js|: il file di configurazione di Truffle.
        \end{itemize}
        \subsubsection{Compilazione degli smart contracts}
        \label{trufflecompile}
        Lanciando il comando \verb|truffle compile| nel progetto vengono compilati tutti gli smart contracts, ossia tutti file con estensione \verb|.sol|, presenti all'interno della cartella \verb|contracts/|.
        Questa operazione genera una nuova directory \verb|build/contracts| contenente un file \verb|.json| per ogni smart contract compilato. Questi file servono per il corretto funzionamento di Truffle quindi la modifica di essi è sconsigliata.
        Inoltre, contengono le ABI\footnote{Application Binary Interface} degli smart contracts, ossia delle interfacce che stanno tra un programma utente e la blockchain Ethereum. Queste sono necessarie perché gli smart contracts, di cui sono stati fatti il deploy, sono sotto forma
        di codici binari e i loro dati sarebbero difficilmente comprensibili. Un' ABI, quindi, descrive le funzioni del suo smart contract ed interpreta i dati di questi metodi. Le  ABI saranno, perciò, necessarie durante l'implementazione dell'applicazione utente.
        \subsubsection{Deploy degli smart contracts}
        Il file \verb|truffle-config.js| permette di definire reti Ethereum che possono essere usate per eseguire il deploy degli smart contracts. Il file ha al suo interno un oggetto \verb|newtorks|, questo contiene la lista delle reti scritte nel seguente formato:
        \begin{lstlisting}[style=ES6, title={Esempio di definizione di una rete Ethereum}]
          <nome_rete>: {
            host: <host>,
            port: <port>,
            network_id: <network_id>
          }\end{lstlisting}
        Dove \verb|host| e \verb|port| indicano l'indirizzo e la porta della rete. \verb|network_id| è, invece, l'identificativo della rete.
        \newline
        Per fare il deploy su una rete specifica si aggiunge l'opzione \verb|--network| al comando \verb|truffle deploy|, perciò, ad esempio,
        se si volesse fare il deploy degli smart contracts su una rete Ethereum chiamata \verb|main|, il comando completo sarebbe:
        \begin{lstlisting}[style=ES6, title={Esempio di deploy specificando la rete}]
          truffle deploy --network main\end{lstlisting}
        Quest'opzione di specificare la rete di destinazione del deploy è utile perché è possibile effettuare il deploy non sulla rete principale di Ethereum, dove sarebbe presente una tassa di ETH, ma su una rete di test locale. 
        \subsubsection{Test degli smart contracts}
        Il comando \verb|truffle test| esegue tutti i file di test inclusi nella cartella \verb|test/|. Per eseguire, invece, un solo file di test lo si specifica nel comando. Quindi ad esempio: \verb|truffle test ./percorso/del/test/file.js|.
        I file di test sono tutti file presenti nella cartella \verb|test/| con una delle seguenti estensioni: \verb|.js|, \verb|.ts|, \verb|.es6|, \verb|.jsx| e \verb|.sol|.
        \newline
        Truffle si avvale di due framework per la scrittura di file di test: \emph{Mocha} e \emph{Chai}\cite{truffleframeworks}. Il primo è un framework per l'esecuzione di test su file Javascript. Il secondo è una libreria per la scrittura di asserzioni,
        ossia espressioni che indicano i valori attesi alla fine di un test.
        \newline
        Un tipico file di test ha la seguente forma:
        \begin{lstlisting}[style=ES6, title={Esempio di file di test}]
          const Contratto = artifacts.require(
            "<smart_contract_da_testare>");
          contract("Contratto", async accounts => {
            describe("<Funzionalita_da_testare>", async () => {
              it("<Comportamento_da_testare>", async () => {
                ....
                assert.equal(
                  <valore_ottenuto>,
                  <valore_atteso>,
                  "<messaggio_da_stampare>"
                );
              });
              it(
                ....
              )
            })
          })\end{lstlisting}
        La riga 1 serve per indicare un file di smart contract usato all'interno del test, per far questo si utilizza \verb|artifacts.require()|.
        Il metodo \verb|contract()| alla riga 3 serve per indicare il contratto da testare. Il comando ha due funzionalità:
        \begin{itemize}
          \item prima di ogni esecuzione di \verb|contract()|, viene rifatto il deploy dei contratti. In questo modo i diversi file di test vengono eseguiti in modo indipendente tra loro;
          \item la funzione \verb|contract()| fornisce una lista di account resi disponibili dalla rete Ethereum usata, questi account possono essere usati nei diversi test.
        \end{itemize}
        Il metodo \verb|describe()| alla riga 4 serve per indicare una funzionalità del contratto che si vuole testare.
        La funzione \verb|it()| indica un comportamento della funzionalità che si vuole controllare.
        \newline
        Per effettuare il controllo di un valore ottenuto rispetto ad un valore atteso, si può utilizzare il comando \verb|assert|, questo fornisce numerosi metodi che eseguono controlli di diverso tipo.
        Nell'esempio si è utilizzato \verb|assert.equal()|, questo controlla che i due parametri passati siano uguali, in caso negativo il test fallisce e viene stampato il messaggio passato come terzo parametro.
        \newpage

        \section{Progettazione}
        L'obiettivo della tesi è lo sviluppo di un sistema di scambio di monete all'interno di CommonsHood. Questo sistema è basato interamente sul meccanismo di domanda e offerta.
        Un utente può, quindi, decidere di non avere più necessità di alcune sue monete, le offre perciò in cambio di altre monete. Un altro utente, che possiede le monete a cui il primo utente è interessato, può accettare lo scambio.
        A questo punto lo scambio è completato e il primo utente riceve le monete che gli interessavano, il secondo utente riceve le monete offerte dal primo utente. In uno scambio, quindi, sono presenti solo due attori:
        da un lato c'è l'utente che crea l'offerta dello scambio definendo le monete coinvolte in questo, dall'altro lato c'è un altro utente che è interessato allo scambio e ne accetta i termini.
        Entrambi, però, hanno un interesse in comune: che lo scambio di monete avvenga correttamente, ovvero i due utenti vogliono assicurarsi che, al termine dello scambio, loro ricevano le monete corrette, ossia vogliono essere certi che l'altro utente
        non possa imbrogliare e non mandare le monete promesse.
        \newline
        Per fare questo, sono state implementate degli smart contracts a cui sono state affidate la gestione del sistema di scambio. Questi smart contracts definiscono le regole e i criteri di uno smart contracts.
        Siccome gli smart contracts sono scritti in codice informatico liberamente consultabile, gli utenti sono certi del funzionamento di uno scambio. A questo punto è solo necessario un'interfaccia grafica per consentire agli utenti
        di usufruire della funzionalità degli scambi.
        \newline
        In questa tesi viene utilizzato il termine "\emph{vendita}" per riferirsi ad uno scambio, le parti di una vendita sono il "\emph{venditore}", colui che crea l'offerta di scambio, e "\emph{compratore}", colui che accetta lo scambio.
        Le monete coinvolte in uno scambio sono state chiamate "\emph{monete da vendere}", ovvero le monete offerte dal venditore, e "\emph{monete da accettare}", ovvero le monete a cui il venditore è interessato e che il compratore deve possedere per poter
        accettare lo scambio.
        \begin{figure}[H]
          \includegraphics[scale=0.9, fbox]{structure.png}
          \centering
          \caption{Schema scambio di monete}
          \centering
          \label{fig:structure}
        \end{figure}
        Nella figura \ref{fig:structure} è rappresentato lo schema del funzionamento dello scambio di monete. L'interfaccia web è stata implementata utilizzando \emph{ReactJS} e sfruttando i componenti di \emph{Material-UI}.
        Sono state create due pagine: "\emph{Create Sale}" e "\emph{Sales List}", la prima permette di creare vendite di monete, la seconda permette di visualizzare le vendite e, eventualmente, accettarle o cancellarle.
        Queste pagine, per svolgere le loro funzioni, hanno bisogno di comunicare con gli smart contracts. Per far ciò utilizzano \emph{Metamask} per connettersi alla blockchain utilizzata. La blockchain è stata creata utilizzando \emph{Ganache} e
        su questa sono stati eseguiti i deploy degli smart contracts che gestiscono la funzionalità dello scambio di monete.
        \newline
        La realizzazione dello scambio di monete è stata divisa in diverse fasi, nella prima sono stati implementati gli smart contracts che regolano una vendita, successivamente si è verificato il corretto funzionamento dei contratti realizzando diversi test,
        nell'ultima fase è stata creata l'interfaccia utente per interagire con i contratti.
        \newline
        Gli smart contracts sono stati realizzati seguendo il modello "\emph{Factory pattern}", in cui un unico oggetto "fabbrica" crea oggetti "prodotti". In questo caso il prodotto della fabbrica è la vendita di monete.
        Sono stati creati, perciò, due smart contracts: \verb|SaleFactory|, ovvero la fabbrica, e \verb|TokenSale|, ovvero il prodotto. Una vendita rappresenta, quindi, lo scambio di monete tra due utenti: da un lato è presente
        il venditore, ovvero colui che ha creato la vendita e offre delle monete in cambio di altre monete che sceglie, dall'altro lato è presente il compratore, ovvero colui che accetta i termini della vendita e completa lo scambio.
        Un utente può interagire in due modi con una vendita: accettarla oppure annullarla. Una vendita si può trovare in tre stati: 
        \begin{itemize}
          \item in corso: la vendita è ancora accettabile;
          \item cancellata: il venditore ha annullato la vendita;
          \item completata: un utente ha accettato lo scambio.
        \end{itemize}
        \begin{figure}[H]
          \includegraphics[scale=0.45, fbox]{saleInteraction.png}
          \centering
          \caption{Creazione e accettazione di una vendita}
          \centering
          \label{fig:saleInteraction}
        \end{figure}
        Quando un venditore crea una vendita deve inviare al suo indirizzo le monete che offre. In questo modo l'utente non può spendere le monete che si trovano già in una vendita. Per assicurarsi che il trasferimento delle monete avvenga, questo viene
        eseguito dal contratto \verb|SaleFactory|, perciò l'utente deve autorizzare la fabbrica a inviare le monete prima che la vendita sia ancora creata. Similarmente, anche quando un utente vuole accettare una vendita deve autorizzare il trasferimento delle monete accettate dalla vendita, ma,
        siccome l'esecutore del trasferimento è in questo caso la vendita, l'approvazione deve essere data all'indirizzo della vendita. Questo è visibile nello schema in figura \ref{fig:saleInteraction}.
        \newline
        Per evitare errori ed eventuali abusi del sistema da parte di utenti, sono state poste delle restrizioni nella gestione delle vendite. In dettaglio si è impedita la creazione di vendite con quantità di monete negative o nulle, vendite con monete da vendere o accettate duplicate.
        Viene inoltre impedita la creazione di una vendita se l'utente non ha approvato il trasferimento delle monete da vendere. Un utente, per accettare una vendita, non deve essere il proprietario della vendita, inoltre deve aver autorizzato la vendita a trasferire le monete accettate.
        Un utente non può accettare una vendita già completata oppure annullata. Una vendita può essere annullata solo dal venditore stesso e solo se la vendita è ancora in corso.

        \section{Scrittura e test degli smart contracts}
        In questa fase sono stati, inizialmente, implementati gli smart contracts che realizzano la funzionalità dell'exchange. Successivamente sono stati realizzati i test per verificare il corretto funzionamento dei contratti implementati.
        \subsection{Scrittura degli smart contracts}
        \label{writeContracts}
        Per la scrittura degli smart contracts è stato usato come codice di base i contratti di CommonsHood che implementano la funzionalità della creazione di monete.
        Gli smart contracts sono stati realizzati seguendo il modello "\emph{Factory Pattern}" per seguire lo standard utilizzato dagli altri contratti di CommonsHood. Quindi, seguendo il pattern, sono stati realizzati
        due smart contracts: la fabbrica \verb|SaleFactory|, il quale ha il compito di creare le vendite, e il prodotto \verb|TokenSale|, ossia la vendita vera e propria.
        \subsubsection{Smart Contract SaleFactory}
        Questo contratto ha il compito di creare e tener traccia delle vendite.
        \paragraph{Variabili ed eventi}
\begin{lstlisting}[style=ES6, title={Variabili ed eventi di SaleFactory}]
address[] internal saleAddresses;
mapping(address => address[]) salesByOwner;

event SaleAdded(
    address indexed _from,
    uint256[] amountsOnSale,
    uint256[] amountsToAccept,
    address owner,
    address saleAddr
);
\end{lstlisting}
        Per tener traccia delle vendite create, \verb|SaleFactory| si avvale di due variabili:
        \begin{itemize}
          \item \verb|saleAddresses|: è un array che contiene gli indirizzi di tutte le vendite create;
          \item \verb|salesByOwner|: è un dizionario con chiave di ricerca l'indirizzo di un utente e con valore associato la lista degli indirizzi delle vendite possedute dall'utente.
        \end{itemize}
        Alla creazione di una vendita viene generato un evento \verb|SaleAdded| che ha come dati l'indirizzo del creatore della vendita, le quantità in vendita e le quantità da accettare come pagamento, l'indirizzo del proprietario della vendita e l'indirizzo della vendita.
        \paragraph{Funzione createSale}
\begin{lstlisting}[style=ES6, title={Funzione createSale()}]
function createSale(
  address[] memory _tokensOnSale,
  address[] memory _tokensToAccept,
  uint256[] memory _amountsOnSale,
  uint256[] memory _amountsToAccept,
  uint256 _expiration
) public returns(address) {
  require(_tokensOnSale.length == _amountsOnSale.length, "All tokens on sale must have an amount on sale");

  require(_tokensToAccept.length == _amountsToAccept.length, "All tokens to accept must have an amount to accept");

  for(uint256 i = 0; i < _tokensOnSale.length; i++) {
    require(_amountsOnSale[i] > 0, "Amounts on sale must be higher than 0");

    require(TokenTemplate(_tokensOnSale[i]).allowance(msg.sender, address(this)) >= _amountsOnSale[i], "Seller has approved tokens on sale");

    for(uint256 j = i+1; j < _tokensOnSale.length; j++) {
      require(_tokensOnSale[i] != _tokensOnSale[j], "Tokens on sale must be different");
    }
  }
  
  for(uint256 i = 0; i < _tokensToAccept.length; i++) {
    require(_amountsToAccept[i] > 0, "Amounts to accept must be higher than 0");

    for(uint256 j = i+1; j < _tokensToAccept.length; j++) {
      require(_tokensToAccept[i] != _tokensToAccept[j], "Tokens to accept must be different");
    }
  }

  for(uint256 i = 0; i < _tokensOnSale.length; i++) {
    for(uint256 j = 0; j < _tokensToAccept.length; j++) {
      require(_tokensOnSale[i] != _tokensToAccept[j], "Tokens on sale must be different from tokens to accept");
    }
  }

  address saleAddr = address(new TokenSale(
    _tokensOnSale,
    _tokensToAccept,
    msg.sender,
    _amountsOnSale,
    _amountsToAccept,
    _expiration,
    address(this)
  ));

  for(uint256 i = 0; i < _tokensOnSale.length; i++) {
    TokenTemplate(_tokensOnSale[i]).transferFrom(msg.sender, saleAddr, _amountsOnSale[i]);
  }

  saleAddresses.push(saleAddr);


  address[] storage ownedSales = salesByOwner[msg.sender];
  ownedSales.push(saleAddr);
  salesByOwner[msg.sender] = ownedSales;

  emit SaleAdded(msg.sender, _amountsOnSale, _amountsToAccept, msg.sender, saleAddr);
  return saleAddr;
}\end{lstlisting}
        Questa funzione permette la creazione di una vendita. Prende in input i dati della vendita da creare, ossia gli indirizzi delle monete da vendere e da accettare, le loro quantità associate e la data di scadenza della vendita.
        Prima di creare la vendita vengono effettuati diversi controlli. Viene controllato che la lista delle monete in vendita sia di lunghezza uguale a quella della lista delle quantità delle monete in vendita. Lo stesso controllo viene eseguito poi sulle monete da accettare.
        Successivamente, viene controllato che tutte le quantità delle monete in vendita siano maggiori di 0, che il venditore abbia approvato la spesa, ossia che \verb|SaleFactory| abbia la \verb|allowance| necessaria, e che le monete i vendita siano diverse tra loro.
        Gli ultimi tre controlli, tranne quello della \verb|allowance|, vengono eseguiti anche per le monete da accettare. L'ultimo controllo verifica che le monete in vendita siano diverse da quelle da accettare.
        Superati i controlli viene effettivamente creata la vendita creando una nuova istanza del contratto \verb|TokenSale|, passando al costruttore di \verb|TokenSale| i parametri di \verb|createSale()|, l'indirizzo del mittente della richiesta di creazione, ossia colui che sarà il proprietario della vendita, e l'indirizzo di \verb|SaleFactory|.
        Viene salvato, inoltre, nella variabile \verb|saleAddr| l'indirizzo della vendita appena creata. Questa sarà utile per le operazioni successive. Una volta creata la vendita, a questa vengono trasferite le quantità di monete in vendita. In questo modo si impedisce al venditore di utilizzare le monete in vendita
        mentre è ancora in corso la vendita. L'indirizzo della vendita viene, quindi, memorizzata in \verb|saleAddresses|, mediante la funzione \verb|push()| dell'array, e in \verb|ownedSales|, con chiave l'indirizzo del venditore e come valore l'array già presente ma con l'aggiunta della nuova vendita.
        Viene infine generato l'evento \verb|SaleAdded|.
        \paragraph{Funzioni getAllSalesAddresses e getPossesedSalesAddresses}
\begin{lstlisting}[style=ES6, title={Funzione getAllSalesAddresses()}]
function getAllSalesAddresses() public view returns(address[] memory) {
  return saleAddresses;
}\end{lstlisting}
\begin{lstlisting}[style=ES6, title={Funzione getPossesedSalesAddresses()}]
function getPossesedSalesAddresses(address _possessor) public view returns(address[] memory) {
    return salesByOwner[_possessor];
}\end{lstlisting}
        Entrambe queste funzioni hanno la dicitura \verb|view| in quanto non modificano i dati nella blockchain, ma semplicemente restituiscono delle informazioni.
        \verb|getAllSalesAddresses| restituisce la lista di tutti gli indirizzi delle vendite. \verb|getPossesedSalesAddresses| prende come parametro un indirizzo e restituisce gli indirizzi delle vendite appartenenti a questo.
        \paragraph{Funzione cancelBatchSales}
\begin{lstlisting}[style=ES6, title={Funzione cancelBatchSales()}]
function cancelBatchSales(address[] memory _salesToCancel) public {
  for(uint256 i = 0; i < _salesToCancel.length; i++) {
    require(msg.sender == TokenSale(_salesToCancel[i]).getSaleOwner(), "User must be the owner of the sale");
    TokenSale(_salesToCancel[i]).cancelSale();
  }
}\end{lstlisting}
        Questa funzione permette la cancellazione di multiple vendite in una volta sola. Prende come parametro la lista delle vendite da eliminare e, per ognuna di queste,
        Viene quindi chiamato il metodo di eliminazione su ogni vendita.
        \subsubsection{Smart Contract TokenSale}
        Il contratto \verb|TokenSale| rappresenta la struttura di una vendita e contiene le funzioni che consentono l'interazione con essa.
        \paragraph{Variabili ed eventi}
\begin{lstlisting}[style=ES6, title={Variabili ed eventi di TokenSale}]
TokenTemplate[] tokensOnSale;
TokenTemplate[] tokensToAccept;

address[] public tokensOnSaleAddr;
address[] public tokensToAcceptAddr;

mapping(address => uint256) amountsOnSale;
mapping(address => uint256) amountsToAccept;

address public owner;
uint256 public expiration;
bool public saleEnded;

address public factoryAddress;

event SaleCompleted(
    address indexed seller,
    address indexed buyer
);

event SaleCancelled(
    address indexed cancelledBy,
    uint256 indexed date
);\end{lstlisting}
        Le variabili utilizzate da \verb|TokenSale| sono le seguenti:
        \begin{itemize}
          \item \verb|tokensOnSale|: array delle monete in vendita;
          \item \verb|tokensToAccept|: array delle monete da accettare;
          \item \verb|tokensOnSaleAddr|: array degli indirizzi delle monete in vendita;
          \item \verb|tokensToAcceptAddr|: array degli indirizzi delle monete da accettare;
          \item \verb|amountsOnSale|: \verb|mapping| che, dato l'indirizzo di una moneta in vendita ne restituisce la quantità in vendita;
          \item \verb|amountsToAccept|: \verb|mapping| che, dato l'indirizzo di una moneta da accettare ne restituisce la quantità da accettare;
          \item \verb|owner|: indirizzo del proprietario della vendita;
          \item \verb|expiration|: data di scadenza della vendita sotto forma di \emph{unix timestamp}, ovvero il numero di secondi passanti dal 1° Gennaio 1970;
          \item \verb|saleEnded|: variabile di tipo \verb|boolean| che ha valore \verb|true| se la vendita è terminata, \verb|false| altrimenti;
          \item \verb|factoryAddress|: indirizzo di \verb|SaleFactory|.
        \end{itemize}
        \verb|TokenSale| può generare due tipi eventi:
        \begin{itemize}
          \item \verb|SaleCompleted|: viene creato questo evento quando la vendita è completata, ossia quando un utente accetta la vendita. Le informazioni contenute nell'evento sono l'indirizzo del proprietario della vendita e l'indirizzo del compratore;
          \item \verb|SaleCancelled|: questo evento viene generato quando la vendita viene eliminata. Le informazioni contenute sono l'indirizzo dell'utente che ha cancellato la vendita e la data di cancellazione.
        \end{itemize}
        \paragraph{Funzione costruttore}
\begin{lstlisting}[style=ES6, title={Funzione costruttore di TokenSale}]
constructor(
  address[] memory _tokensOnSale,
  address[] memory _tokensToAccept,
  address _owner,
  uint256[] memory _amountsOnSale,
  uint256[] memory _amountsToAccept,
  uint256 _expiration,
  address _factoryAddress
) public{
  for(uint256 i = 0; i < _tokensOnSale.length; i++) {
    tokensOnSale.push(TokenTemplate(_tokensOnSale[i]));
    tokensOnSaleAddr.push(_tokensOnSale[i]);
    amountsOnSale[_tokensOnSale[i]] = _amountsOnSale[i];
  }
  for(uint256 i = 0; i < _tokensToAccept.length; i++) {
    tokensToAccept.push(TokenTemplate(_tokensToAccept[i]));
    tokensToAcceptAddr.push(_tokensToAccept[i]);
    amountsToAccept[_tokensToAccept[i]] = _amountsToAccept[i];
  }

  owner = _owner;
  expiration = _expiration;
  factoryAddress = _factoryAddress;
  saleEnded = false;
}\end{lstlisting}
        Questa funzione rappresenta il costruttore di \verb|TokenSale|, ossia è il metodo eseguito alla creazione di una nuova istanza di \verb|TokenSale|, ovvero alla creazione di una vendita.
        Prende come parametri la lista degli indirizzi delle monete in vendita e da accettare, le loro quantità, l'indirizzo del proprietario della vendita, la data di scadenza sotto forma di \emph{timestamp}
        e l'indirizzo di \verb|SaleFactory|. Non è necesario fare i controlli sui parametri in quanto sono già stati verificati nel metodo chiamante \verb|createSale()| contenuto in \verb|SaleFactory|.
        Per ogni indirizzo delle monete in vendita si ottiene l'istanza della moneta e questa viene inserita nell'array \verb|tokensOnSale|, l'indirizzo viene invece inserito in \verb|tokensOnSaleAddr|, nel \verb|mapping| \verb|amountsOnSale|
        viene associato all'indirizzo la quantità in vendita della moneta. Lo stesso viene eseguito anche per gli indirizzi delle monete da accettare. Successivamente vengono assegnati i valori alle variabili \verb|owner|, \verb|expiration| e \verb|factoryAddress| con i parametri passati.
        In quanto una vendita nuova per definizione non è completata, \verb|saleEnded| è inizializzata a \verb|false|.
        \paragraph{Funzione acceptSale}
\begin{lstlisting}[style=ES6, title={Funzione acceptSale()}]
function acceptSale() public {
  require(saleEnded == false, "Sale has to be still on going");
  require(owner != msg.sender, "Buyer has to be different than the sale owner");

  for(uint256 i = 0; i < tokensToAccept.length; i++) {
    require(tokensToAccept[i].allowance(msg.sender, address(this)) >= amountsToAccept[tokensToAcceptAddr[i]], "Buyer has approved the sale contract to transfer enough tokens to accept");
    tokensToAccept[i].transferFrom(msg.sender, owner, amountsToAccept[tokensToAcceptAddr[i]]);
  }
  
  for(uint256 i = 0; i < tokensOnSale.length; i++) {
    tokensOnSale[i].transfer(msg.sender, amountsOnSale[tokensOnSaleAddr[i]]);
  }
  
  emit SaleCompleted(owner, msg.sender);
  saleEnded = true;
}\end{lstlisting}
        Questa funzione permette al chiamante di accettare la vendita su cui è stata chiamata. La funzione controlla che la vendita non sia già terminata e che il chiamante non sia il venditore stesso.
        Inoltre verifica che il contratto abbia l'autorizzazione del compratore a spendere le sue monete. Superati i controlli vengono trasferite le monete interessate dalla vendita. Quindi le monete in vendita vengono trasferite dal contratto all'indirizzo del compratore,
        mentre le monete da accettare vengono trasferite dal compratore al proprietario della vendita. Infine viene emesso l'evento \verb|SaleCompleted| indicando gli indirizzi di venditore e compratore e, siccome la vendita è conclusa, \verb|saleEnded| viene posto a \verb|true|.
        \paragraph{Funzione cancelSale}
\begin{lstlisting}[style=ES6, title={Funzione cancelSale()}]
function cancelSale() public {
  require(msg.sender == owner || msg.sender == factoryAddress, "Only the sale creator or the factory can cancel it");
  require(saleEnded == false, "Sale has to be still on going");

  for(uint256 i = 0; i < tokensOnSale.length; i++) {
    tokensOnSale[i].transfer(owner, amountsOnSale[tokensOnSaleAddr[i]]);
  }
  
  saleEnded = true;

  emit SaleCancelled(msg.sender, now);
}\end{lstlisting}
        Questa funzione permette al venditore di anullare la vendita su cui è chiamata. Verifica che il chiamante sia il proprietario della vendita e che la vendita sia ancora in corso. Successivamente restituisce le monete al vendite. Quindi trasferisce i fondi dal contratto al proprietario.
        Infine pone \verb|saleEnded| a \verb|true| e emette l'evento \verb|SaleCancelled| indicando il chiamante della funzione e la data della chiamata.
        \paragraph{Funzioni per ottenere informazioni}
\begin{lstlisting}[style=ES6, title={Funzioni per ottenere informazioni}]
function getTokensOnSaleAddr() public view returns(address[] memory) {
    return tokensOnSaleAddr;
  }

function getTokensToAcceptAddr() public view returns(address[] memory) {
  return tokensToAcceptAddr;
}

function getSaleExpiration() public view returns(uint256) {
  return expiration;
  }

function getSaleOwner() public view returns(address) {
  return owner;
}

function getSaleInfo() public view returns(address, bool, address[] memory, uint256[] memory, address[] memory, uint256[] memory, uint256) {
  uint256[] memory retAmountsOnSale = new uint256[](tokensOnSaleAddr.length);
  uint256[] memory retAmountsToAccept = new uint256[](tokensToAcceptAddr.length);

  for(uint256 i = 0; i < tokensOnSaleAddr.length; i++) {
    retAmountsOnSale[i] = amountsOnSale[tokensOnSaleAddr[i]];
  }

  for(uint256 i = 0; i < tokensToAcceptAddr.length; i++) {
    retAmountsToAccept[i] = amountsToAccept[tokensToAcceptAddr[i]];
  }

  uint256 exp = expiration;

  return (
    owner,
    saleEnded,
    tokensOnSaleAddr,
    retAmountsOnSale,
    tokensToAcceptAddr,
    retAmountsToAccept,
    exp
  );
}\end{lstlisting}
        Queste funzioni restituiscono informazioni sulla vendita su cui sono chiamate. Siccome non modificano dati hanno tutte la dicitura \verb|view|.
        \begin{itemize}
          \item \verb|getTokensOnSaleAddr()|: restituisce l'array delle monete in vendita;
          \item \verb|getTokensToAcceptAddr()|: restituisce l'array delle monete da accettare;
          \item \verb|getSaleExpiration()|: restituisce la data di scadenza della vendita;
          \item \verb|getSaleOwner()|: restituisce l'indirizzo del venditore;
          \item \verb|getSaleInfo()|: restituisce tutte le informazioni sulla vendita. Siccome in Solidity le funzioni non possono restituire oggetti di tipo \verb|mapping|, i valori di \verb|amountsOnSale| e \verb|amountsToAccept| sono stati prima trasferiti in due array.
        \end{itemize}
        \subsection{Test degli smart contract}
        Per effettuare il test degli smart contracts descritti in \ref{writeContracts} è stato creato il file \verb|SaleFactoryAndTemplate.js| all'interno della cartella \verb|test/|. In questo sono stati implementati i vari test per verificare il corretto comportamento dei contratti.
        I test sono stati suddivisi nelle tre funzionalità primarie da verificare: la creazione di una vendita, il completamento di una vendita e la cancellazione di una vendita.
        \subsubsection{Variabili e funzioni di supporto}
        Per facilitare la scrittura dei test sono stati definite alcune variabili e funzioni di supporto.
        \paragraph{Variabili di supporto}
        \label{testVars}
\begin{lstlisting}[style=ES6, title={Variabili di supporto nel test}]
const tokenOnSaleOne = {
  name: "Sale Accept Token",
  symbol: "CRACC",
  decimals: 18,
  logoURL:
    "https://apollo-uploads-las.s3.amazonaws.com/1442324623/atlanta-hawks-logo-944556.png",
  logoHash: web3.utils.toHex(
    "0x4D021B157A49F472A48AB02A1F2F6E2986C169A7C78CC94179EDAEBD5E96E8E4"
  ),
  contractHash: web3.utils.toHex(
    "0x4D021B157A49F472A48AB02A1F2F6E2986C169A7C78CC94179EDAEBD5E96E8E4"
  ),
  supply: 100000
};

const tokenOnSaleTwo = {
  name: "Sale Accept Token Two",
  symbol: "CRACT",
  ...
  supply: 100000
};

const tokenToAcceptOne = {
  name: "Sale Give Token",
  symbol: "CRGIV",
  ...
  supply: 100000
};

const tokenToAcceptTwo = {
  name: "Sale Give Token Two",
  symbol: "CRGIT",
  ...
  supply: 100000
};

const amountsOnSale = [1, 1];
const amountsToAccept = [1, 1];

const seller = accounts[0];
const buyer = accounts[1];\end{lstlisting}
        Sono state definite quattro monete da utilizzare per le vendite, due per le monete da vendere e due per le monete accettate. Le quantità delle monete in vendita e accettate sono state impostate a 1 e indicate da
        \verb|amountsOnSale| e \verb|amountsToAccept|. \verb|seller| e \verb|buyer| contengono due indirizzi forniti dall'ambiente di test, il primo verrà usato per creare le vendite mentre il secondo per accettarle.
        \paragraph{Funzioni di supporto}
        \label{supportFun}
\begin{lstlisting}[style=ES6, title={Funzioni di supporto nel test}]
async function setupContracts(seller, buyer, tokenOnSaleOne, tokenOnSaleTwo, tokenToAcceptOne, tokenToAcceptTwo) {
  TokenFactoryInstance = await TokenFactory.new();

  let tokensOnSaleAddr = [];
  let tokensToAcceptAddr = [];

  let transaction = await TokenFactoryInstance.createToken(
    tokenOnSaleOne.name,
    tokenOnSaleOne.symbol,
    tokenOnSaleOne.decimals,
    tokenOnSaleOne.logoURL,
    tokenOnSaleOne.logoHash,
    tokenOnSaleOne.supply,
    tokenOnSaleOne.contractHash,
    { from: seller }
  );
  tokensOnSaleAddr.push(transaction.receipt.logs[0].args._contractAddress);

  transaction = await TokenFactoryInstance.createToken(
    ...
    { from: seller }
  );
  tokensOnSaleAddr.push(transaction.receipt.logs[0].args._contractAddress);

  transaction = await TokenFactoryInstance.createToken(
    ...
    { from: buyer }
  );
  tokensToAcceptAddr.push(transaction.receipt.logs[0].args._contractAddress);

  transaction = await TokenFactoryInstance.createToken(
    ...
    { from: buyer }
  );
  tokensToAcceptAddr.push(transaction.receipt.logs[0].args._contractAddress);

  return [tokensOnSaleAddr, tokensToAcceptAddr];
}

async function createSale(seller, tokensOnSaleAddr, tokensToAcceptAddr, amountsOnSale, amountsToAccept) {
  const saleFactoryInstance = await SaleFactory.new();

  for(const tokenOnSaleAddr of tokensOnSaleAddr) {
    let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);

    await tokenOnSaleInstance.approve(saleFactoryInstance.address, amountsOnSale[0], { from: seller });
  }

  const expiration = 0;

  const transaction = await saleFactoryInstance.createSale(
    tokensOnSaleAddr,
    tokensToAcceptAddr,
    amountsOnSale,
    amountsToAccept,
    expiration,
    { from: seller }
  )
  const saleAddr = transaction.receipt.logs[0].args.saleAddr;

  return saleAddr
}

const assertFailError = error => {
    assert.fail(`
      Should always be able to call smart contracts, got instead this error:
      caused by: 
      ${error.stack}
      Reason: "${error.reason}"`);
};
\end{lstlisting}
        La funzione \verb|setupContracts()| serve per creare le istanze delle monete dichiarate in \ref{testVars}, quelle in vendita vengono create dal venditore mentre quelle da accettare sono create dal compratore.
        In questo modo entrambi gli account hanno i fondi per eseguire le loro azioni nei test. Per l'istanziazione viene prima creata l'istanza di \verb|TokenFactory|, ovvero lo smart contract responsabile della creazione di monete,
        e su questo viene chiamato il metodo \verb|createToken()| passando i dati della moneta da creare. La funzione restituisce gli array degli indirizzi delle monete in vendita e da accettare.
        \newline
        La funzione \verb|createSale()| è usata per creare le vendite. Viene prima creata l'istanza di \verb|SaleFactory|, il contratto responsabile per la creazione di vendite. Successivamente il venditore approva l'istanza di \verb|SaleFactory| a spendere le monete in vendita.
        Per far questo, sulle istanze delle monete viene chiamata la funzione \verb|approve| e indicando, usando la dicitura \verb|from|, l'indirizzo del venditore come mittente della chiamata. Per comodità la data di scadenza è stata impostata a 0, ossia la vendita non ha data di scadenza.
        Viene quindi creata la vendita con il metodo \verb|createSale()| fornito da \verb|SaleFactory| e ne viene restituito l'indirizzo.
        \newline
        La funzione \verb|assertFailError()| provoca il fallimento del test e stampa l'errore passato come parametro.
        \subsubsection{Test sulla creazione di una vendita}
        I test della funzionalità di creazione di una vendita sono tutte all'interno di \verb|describe("Sale Creation", ...)|. Prima di iniziare i test vengono istanziate le monete interessate dalla vendita chiamando la funzione \verb|setupContracts()| descritta in \ref{supportFun}.
        Il principale comportamento del contratto da verificare è che crei correttamente la vendita.
\begin{lstlisting}[style=ES6, title={Il contratto crea correttamente una vendita}]
it("Creates Sale", async () => {
  try {
    saleAddr = await createSale(seller, tokensOnSaleAddr, tokensToAcceptAddr, amountsOnSale, amountsToAccept);

    const tokenSaleInstance = await TokenSale.at(saleAddr);
    const toCheckTokensOnSaleAddr = await tokenSaleInstance.getTokensOnSaleAddr();
    const toCheckTokensToAcceptAddr = await tokenSaleInstance.getTokensToAcceptAddr();

    for(const tokenOnSaleAddr of tokensOnSaleAddr) {
      let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);

      assert(toCheckTokensOnSaleAddr.includes(tokenOnSaleAddr), "Sale should have the correct tokens on sale");
      assert.equal(await tokenOnSaleInstance.balanceOf(saleAddr), amountsOnSale[0], "Sale contract should have received the amount of tokens on sale");
    }

    for(const tokenToAcceptAddr of tokensToAcceptAddr) {
      assert(toCheckTokensToAcceptAddr.includes(tokenToAcceptAddr), "Sale should have the correct tokens to be accepted");
    }
  } catch(error) {
    assertFailError(error);
  }
});\end{lstlisting}
        Questo test crea una vendita e verifica che il contratto della vendita abbia ricevuto le corrette quantità di monete da vendere dal venditore. Controlla inoltre che la vendita abbia impostate correttamente le monete da accettare.
        In caso di errore nel processo di creazione viene eseguito il blocco \verb|catch| che cattura l'errore e richiama \verb|assertFailError()| che provoca il fallimento del test.
        Gli altri test eseguiti sono:
        \begin{itemize}
          \item \spverb|it("Should not allow the creation of a sale with duplicate   token on sale")|: controlla che venga correttamente impedita la creazione di una vendita con monete in vendita duplicate;
          \item \spverb|it("Should not allow the creation of a sale with duplicate   token to accept")|: effettua lo stesso controllo precedente ma per le monete da accettare;
          \item \spverb|it("Should not allow the creation of a sale with same token  on sale and to accept")|: controlla che venga impedita la creazione di una vendita con una stessa moneta sia in vendita che da accettare.
        \end{itemize}
        \subsubsection{Test sul completamento di una vendita}
        Questi test, posizionati all'interno di \verb|describe("Sale completed", ...)|, verificano che una vendita venga accettata dal compratore in modo corretto.
\begin{lstlisting}[style=ES6, title={Il compratore accetta correttamente una vendita}]
it("Sells the tokens", async () => {
try {
  let initialSellerBalance = [];
  let initialBuyerBalance = [];

  for(const tokenOnSaleAddr of tokensOnSaleAddr) {
      let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);
      
      initialSellerBalance.push(await tokenOnSaleInstance.balanceOf(seller));
  }

  for(const tokenToAcceptAddr of tokensToAcceptAddr) {
      let tokenToAcceptInstance = await TokenTemplate.at(tokenToAcceptAddr);

      initialBuyerBalance.push(await tokenToAcceptInstance.balanceOf(buyer));
  }

  saleAddr = await createSale(seller, tokensOnSaleAddr, tokensToAcceptAddr, amountsOnSale, amountsToAccept);

  const tokenSaleInstance = await TokenSale.at(saleAddr);

  let i = 0;
  for(const tokenToAcceptAddr of tokensToAcceptAddr) {
      let tokenToAcceptInstance = await TokenTemplate.at(tokenToAcceptAddr);

      await tokenToAcceptInstance.approve(saleAddr, amountsToAccept[i], { from: buyer});
      i++;
  }

  await tokenSaleInstance.acceptSale({ from: buyer});
  i = 0;
  for(const tokenOnSaleAddr of tokensOnSaleAddr) {
      let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);
      
      assert.equal(await tokenOnSaleInstance.balanceOf(seller, { from: seller}), initialSellerBalance[i]-amountsOnSale[i], "[POST-SALE] Seller has the correct amount of tokens on sale after the sale");
      assert.equal(await tokenOnSaleInstance.balanceOf(buyer, { from: buyer}), amountsOnSale[i], "[POST-SALE] Buyer has bought the correct number of tokens");
      i++;
  }
  
  i = 0;
  for(const tokenToAcceptAddr of tokensToAcceptAddr) {
      let tokenToAcceptInstance = await TokenTemplate.at(tokenToAcceptAddr);

      assert.equal(await tokenToAcceptInstance.balanceOf(buyer, { from: buyer}), initialBuyerBalance[i]-amountsToAccept[i], "[POST-SALE] Buyer has the correct amount of tokens after the sale");
      assert.equal(await tokenToAcceptInstance.balanceOf(seller, { from: seller}), amountsToAccept[i], "[POST-SALE] Seller has received the payment");
      i++;
  }

  assert.equal(await tokenSaleInstance.saleEnded(), true, "[POST-SALE] Sale has ended");
} catch(error) {
  assertFailError(error);
}
});
\end{lstlisting}
        In questo test il venditore crea la vendita, il compratore approva il contratto della vendita a spendere le monete in vendita e, quindi, accetta la vendita. Il test verifica che il venditore e il compratore abbiano ricevuto le corrette quantità di monete e controlla che la vendita sia nello stato "terminato".
        I test secondari sono:
        \begin{itemize}
          \item \spverb|it("Should not allow the seller to accept the sale")|: controlla che il venditore non possa accettare la sua stessa vendita;
          \item \spverb|it("Should not allow the buyer to accept an ended sale")|: \newline controlla che il compratore non possa accettare una vendita già terminata;
          \item \spverb|it("Should not complete the sale if the buyer has not yet    approved the sale contract for the trasfer of the tokens to  accept")|: controlla che il compratore non possa accettare la vendita se prima non ha approvato il trasferimento dei fondi.
        \end{itemize}
        \subsubsection{Test sulla cancellazione di una vendita}
        La funzione \verb|describe("Cancel sale", ...)| contiene i test che verificano il corretto funzionamento della cancellazione di una vendita.
\begin{lstlisting}[style=ES6, title={La vendita viene correttamente cancellata}]
it("Cancels the sale successfully", async () => {
  try {
    let initialSellerBalance = [];

    for(const tokenOnSaleAddr of tokensOnSaleAddr) {
      let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);
      
      initialSellerBalance.push(await tokenOnSaleInstance.balanceOf(seller));
    }

    saleAddr = await createSale(seller, tokensOnSaleAddr, tokensToAcceptAddr, amountsOnSale, amountsToAccept);

    const tokenSaleInstance = await TokenSale.at(saleAddr);

    let i = 0;
    for(const tokenOnSaleAddr of tokensOnSaleAddr) {
      let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);

      assert.equal(await tokenOnSaleInstance.balanceOf(seller, { from: seller}), initialSellerBalance[i] - amountsOnSale[i], "[PRE-CANCEL] Seller transferred the tokens on sale");
      i++;
    }
    

    await tokenSaleInstance.cancelSale({ from: seller});

    i = 0;
    for(const tokenOnSaleAddr of tokensOnSaleAddr) {
      let tokenOnSaleInstance = await TokenTemplate.at(tokenOnSaleAddr);
      
      assert.equal(await tokenOnSaleInstance.balanceOf(seller, { from: seller}), initialSellerBalance[i].toNumber(), "[POST-CANCEL] Seller got refunded");
      i++;
    }

    assert.equal(await tokenSaleInstance.saleEnded(), true, "[POST-CANCEL] Sale has ended");
  } catch(error) {
    assertFailError(error);
  }
});
\end{lstlisting}
        In questo test il venditore crea una vendita e poi la cancella chiamando la funzione \verb|cancelSale()|. Viene controllato che il venditore, dopo la cancellazione della vendita, riceva indietro le monete trasferite durante la creazione della vendita. Si verifica, inoltre, il termine della vendita.

        \newpage
        \section{Implementazione dell'interfaccia grafica}
        L'interfaccia utente che implementa le funzionalità di scambio di token è stata divisa in due pagine.
        La prima è chiamata \emph{Create Sale} e, scegliendo i token da vendere e quelli da accettare, permette
        la creazione di una vendita. La seconda è chiamata \emph{Sales List} e permette di visualizzare la lista di tutte le vendite, sia quelle in corso
        che quelle terminate.
        \newline
        Per implementare l'interfaccia si è utilizzato un boilerplate avente solo la funzionalità di creazione di monete\cite{boilerplate}. Da questa base, quindi, è stata sviluppata la funzionalità di vendita di monete. 

        \subsection{Struttura dell'applicazione web}
        \dirtree{%
          .1 Commmonshood-frontend/.
          .2 src/.
          .3 APIs/.
          .4 coin.js.
          .3 assets/.
          .3 components/.
          .3 config/.
          .4 config.js.
          .3 theme/.
          .4 theme.js.
        }
        Questo albero rappresenta la struttura del progetto che implementa l'interfaccia grafica. La cartella \verb|APIs/| contiene i file che implementano i metodi per comunicare con la blockchain.
        Inizialmente è presente il solo file \verb|coin.js|, ossia il file che contiene le funzioni che gestiscono i token.
        \newline
        \verb|assets/| contiene le immagini utilizzate dall'applicazione.
        \newline
        \verb|components/| contiene tutti i componenti \emph{ReactJS} creati e utilizzati nelle pagine dell'applicazione.
        \newline
        \verb|config/| è una cartella che contiene il file \verb|config.js|. Quest'ultimo è un file di configurazione che contiene i parametri di \emph{Ganache} per comunicare con la blockchain e gli indirizzi e le ABI degli smart contracts utilizzati.
        \newline
        \verb|theme/| contiene il file \verb|theme.js| che definisce lo schema dei colori utilizzati dall'app.

        \subsection{Azioni preliminari}
        Prima di iniziare la fase d'implementazione dell'interfaccia grafica, è necessario impostare correttamente \emph{Metamask} e cambiare i parametri del file di configurazione \verb|config.js| della web app presente nella cartella \verb|src/config|.
        \subsubsection{Impostazione di Metamask}
        È necessario impostare correttamente \emph{Metamask} per permettere la corretta connessione con la \emph{blockchain} di test utilizzato nella fase precedente.
        Per far questo si prende l'informazione di \verb|RPC SERVER| da Ganache. Successivamente è necessario creare una nuova rete su \emph{Metamask}. Per far ciò, si entra nelle impostazioni delle reti dell'estensione del browser, si seleziona la voce "\emph{Aggiungi Reti}".
        Nella pagina successiva, alla voce "\emph{Nuovo URL RPC}" si inserisce l'indirizzo \verb|RPC SERVER| dato da Ganache, invece alla voce "\emph{Chain ID}" si inserisce il numero 1337, come descritto dalla documentazione di \emph{Truffle}\cite{trufflechain}.
        Terminata questa operazione è possibile connettersi alla nuova rete collegata, ma è ancora necessario importare almeno un account fornito da \emph{Ganache}. Quindi, dalla pagina "\emph{I miei account}" di \emph{Metamask} si seleziona la voce "\emph{Importa account}".
        Alla voce "\emph{Incolla la tua chiave privata qui:}", si inserisce la chiave privata di un account di \emph{Ganache}. Per trovare questa chiave è necessario, dalla pagina principale di \emph{Ganache}, selezionare il simbolo di chiave associato a un account, nella finestra che si apre è presente la chiave privata alla voce "\verb|private key|".
        \subsubsection{Impostazione del file di configurazione}
        Per configurare correttamente il file \verb|config.js|, si modificano le variabili \verb|ETH_POA_NETWORK_ID| e \verb|RPC_ENDPOINT| con le informazioni di "\emph{Network ID}" e "\emph{RPC Server}" di \emph{Ganache}.
        Inoltre, all'oggetto \verb|SMART_CONTRACTS| si aggiungono tre nuove voci:
        \begin{itemize}
          \item \verb|SALE_FCTRY_ADDR|: contiene l'indirizzo del contratto di \verb|saleFactory|;
          \item \verb|SALE_FCTRY_ABI|: contiene l'ABI di \verb|saleFactory|;
          \item \verb|SALE_TMPLT_ABI|: contiene l'ABI di \verb|saleTemplate|.
        \end{itemize}
        L'informazione dell'indirizzo si prende da Ganache nella sezione "\emph{Contracts}". Le ABI, invece, si prendono dall'output del comando \verb|truffle compile|, come descritto in \ref{trufflecompile}.
        \newline
        Infine, si deve cambiare anche il valore di \verb|TKN_FCTRY_ADDR| con l'indirizzo di \verb|tokenFactory|, preso, sempre, da \emph{Ganache}.

        \subsection{File sale.js}
        All'interno della directory \verb|src/APIs/| è stato creato un file chiamato \verb|sale.js|. Lo scopo di questo file è quello di contenere tutti i metodi che effettuano le chiamate alle funzioni degli smart contracts
        relative alla vendita di token. Per far questo il file importa l'oggetto \verb|SMART_CONTRACTS| da \verb|config.js|.
        \subsubsection{saleCreate}
        \begin{lstlisting}[style=ES6, title={Funzione saleCreate()}]
export const saleCreate = async (web3, sellerAddress, coinsOnSaleAddr, amountsOnSale, coinsToAcceptAddr, amountsToAccept, expirationDate) => {
  try {
    for(let i = 0; i < coinsOnSaleAddr.length; i++) {
      const coinInstance = new web3.eth.Contract(
        SMART_CONTRACTS.TKN_TMPLT_ABI,
        coinsOnSaleAddr[i],
      );

      await coinInstance.methods.approve(
        SMART_CONTRACTS.SALE_FCTRY_ADDR,
        amountsOnSale[i]
      ).send({from: sellerAddress, gasPrice: "0"});
    }

    const SaleFactoryInstance = new web3.eth.Contract(
      SMART_CONTRACTS.SALE_FCTRY_ABI,
      SMART_CONTRACTS.SALE_FCTRY_ADDR,
    );

    const creationResponse = await 
      SaleFactoryInstance.methods.createSale(
      coinsOnSaleAddr,
      coinsToAcceptAddr,
      amountsOnSale,
      amountsToAccept,
      expirationDate
    ).send({from: sellerAddress, gasPrice: "0"});

    return creationResponse.events.SaleAdded.returnValues.saleAddr;
  } catch (error) {
    for(let i = 0; i < coinsOnSaleAddr.length; i++) {
      const coinInstance = new web3.eth.Contract(
        SMART_CONTRACTS.TKN_TMPLT_ABI,
        coinsOnSaleAddr[i],
      );

      await coinInstance.methods.approve(
        SMART_CONTRACTS.SALE_FCTRY_ADDR, 0
      ).send({from: sellerAddress, gasPrice: "0"});
    }
    return false;
  }
}\end{lstlisting}
        Questo metodo permette la creazione di una vendita. Prende come parametri l'istanza di \verb|web3|, l'indirizzo del venditore, la lista dei token in vendita e le loro quantità,
        la lista dei token accettati come pagamento e la loro quantità e la data di scadenza della vendita.
        \newline
        Il corpo della funzione è racchiuso all'interno di un blocco \verb|try/catch|, in questo modo, in caso di fallimento delle chiamate alle funzioni degli smart contracts, si può gestire l'errore e comunicarlo al chiamante.
        \newline
        Il blocco \verb|for| da riga 3 a riga 13 serve per ottenere le istanze dei contratti di ogni token in vendita \verb|coinsOnSaleAddr| e, successivamente, chiamare il metodo \verb|approve()| su essi.
        Alle chiamate del metodo \verb|approve()| vengono passati come parametri l'indirizzo del contratto \verb|SaleFactory| e la quantità associata al token sulla cui istanza si sta effettuando la chiamata.
        In questo modo si permette all'utente di approvare \verb|SaleFactory| a spendere per ogni moneta in vendita la loro quantità in vendita.
        \newline
        Le chiamate ad \verb|approve()|, inoltre, hanno bisogno alla fine del metodo \verb|send()|,
        questo perché le funzioni che modificano lo stato del contratto hanno bisogno di inviare una transazione. Questo viene eseguito, appunto, con \verb|send()|\cite{soliditysend}.
        \newline
        Alla riga 15 si ottiene l'istanza del smart contract \verb|SaleFactory|. Questo viene effettuato creando un nuovo oggetto di tipo \verb|web3.eth.Contract|, passando come parametri l'ABI e l'indirizzo del contratto.
        Questo funziona, naturalmente, solo se è già stato fatto il deploy del contratto di cui si sta cercando di ottenere l'istanza.
        \newline
        Ottenuto l'istanza di \verb|SaleFactory|, si può creare la vendita. Questo è realizzato chiamando alla riga 20 il metodo \spverb|SaleFactoryInstance.methods .createSale()|, passando come parametri le opzioni della vendita,
        ossia le monete in vendita e da accettare, le loro quantità e la data di scadenza.
        \newline
        Infine viene restituito al chiamante l'indirizzo della vendita appena creata. Questo è ottenuto dall'evento \verb|SaleAdded|, preso dalla lista degli eventi nella risposta della chiamata a \verb|SaleFactoryInstance.methods.createSale()|.
        \newline
        In caso di fallimento di un'operazione in questo blocco \verb|try|, l'errore verrebbe gestito dal blocco \verb|catch| alla riga 30. Questo ottiene nuovamente le istanze delle varie monete in vendita e, dunque, per ogni moneta effettua il reset della
        \verb|allowance| di \verb|SaleFactory|. Questo significa che \verb|SaleFactory| non ha più il permesso di spendere le monete in vendita del venditore. Questo viene effettuato semplicemente usando sempre il metodo \verb|approve()| ma, in questo caso,
        come quantità viene passato 0.
        \subsubsection{saleGetAll}
        \begin{lstlisting}[style=ES6, title={Funzione saleGetAll}]
export const saleGetAll = async (web3, accountAddress) => {
  let salesList = [];

  try {
    const SaleFactoryInstance = new web3.eth.Contract(
      SMART_CONTRACTS.SALE_FCTRY_ABI,
      SMART_CONTRACTS.SALE_FCTRY_ADDR,
    );

    const salesAddresses = await SaleFactoryInstance.methods.getAllSalesAddresses().call({ from: accountAddress, gasPrice: "0"});

    if(salesAddresses.length !== 0) {
      const salesInstances = [];

      for(let i = 0; i < salesAddresses.length; i++) {
        salesInstances.push(new web3.eth.Contract(
          SMART_CONTRACTS.SALE_TMPLT_ABI,
          salesAddresses[i],
        ));
      }

      for(let i = 0; i < salesInstances.length; i++) {
        const saleInfo = await salesInstances[i].methods.getSaleInfo().call({ from: accountAddress, gasPrice: "0"});

        let tokensOnSaleData = [];
        let tokensToAcceptData = [];
        const saleOwner = saleInfo[0];
        const saleEnded = saleInfo[1];
        const saleExpiration = saleInfo[6];

        const tokensOnSaleAddr = saleInfo[2];
        const amountsOnSale = saleInfo[3];
        for(let i = 0; i < tokensOnSaleAddr.length; i++) {
          const tokenData = await coinGetFullData(web3, accountAddress, tokensOnSaleAddr[i]);
          tokenData['address'] = tokensOnSaleAddr[i];
          tokenData['amount'] = amountsOnSale[i];
          tokensOnSaleData.push(tokenData);
        }

        const tokensToAcceptAddr = saleInfo[4];
        const amountsToAccept = saleInfo[5];
        for(let i = 0; i < tokensToAcceptAddr.length; i++) {
          const tokenData = await coinGetFullData(web3, accountAddress, tokensToAcceptAddr[i]);
          tokenData['address'] = tokensToAcceptAddr[i];
          tokenData['amount'] = amountsToAccept[i];
          tokensToAcceptData.push(tokenData);
        }

        const saleCompleted = await salesInstances[i].getPastEvents("SaleCompleted");

        const buyer = saleCompleted[0]?.returnValues.buyer;

        const saleData = {
          address: salesAddresses[i],
          owner: saleOwner,
          ended: saleEnded,
          buyer: buyer,
          tokensOnSaleData: tokensOnSaleData,
          amountsOnSale: amountsOnSale,
          tokensToAcceptData: tokensToAcceptData,
          amountsToAccept: amountsToAccept,
          expiration: saleExpiration
        }
        salesList.push(saleData);
      }
    }
    return salesList;
  } catch(error) { 
    return [];
  }
}\end{lstlisting}
        La funzione \verb|saleGetAll()| restituisce al chiamante la lista di tutte le vendite. Prende come parametri l'istanza di \verb|web3|, l'indirizzo del venditore.
        \newline
        Viene creato inizialmente l'array di ritorno \verb|salesList| vuoto.
        Alla riga 5 viene presa l'istanza di \verb|SaleFactory|, questa viene usata per ottenere la lista degli indirizzi di tutte le vendite usando la funzione \spverb|SaleFactoryInstance. methods.getAllSalesAddresses()|.
        Quest'ultima ha bisogno alla fine del metodo \verb|call()|. Viene usato questo metodo al posto di \verb|send()| perché la funzione \verb|getAllSalesAddresses()| non altera lo stato dello smart contract,
        perciò non c'è necessità di inviare una transazione\cite{soliditycall}.
        \newline
        Se la lista degli indirizzi delle vendite è di lunghezza 0, ovvero è vuota, la funzione termina restituendo al chiamante l'array vuoto. Altrimenti la funzione prosegue con le operazioni successive.
        \newline
        Alla riga 15 vengono ottenute le istanze di tutti gli indirizzi delle vendite, queste vengono memorizzate all'interno di un array chiamato \verb|salesInstances|. Successivamente viene chiamata la funzione \verb|getAllSalesAddresses()| per ogni istanza di vendita,
        questa restituisce le informazioni della vendita che vengono salvate in alcune variabili. Tra queste informazioni sono presenti anche gli indirizzi dei token in vendita e da accettare, da questi si devono ottenere anche le informazioni sulle monete.
        Questo viene eseguito nel blocco \verb|for| alla riga 33: su ogni indirizzo delle monete in vendita viene richiamato il metodo \verb|coinGetFullData()| che restituisce i dati della moneta passata come parametro.
        L'operazione precedente viene ripetuta nel \verb|for| alla riga 42 per le monete da accettare.
        Alla riga 49 viene chiamata la funzione \verb|getPastEvents()| su un'istanza di vendita passando come parametro "\emph{SaleCompleted}". Questa funzione restituisce l'evento specificato come parametro, se esiste, altrimenti restituisce \verb|null|.
        Alla riga 51 alla variabile \verb|buyer| viene assegnato l'indirizzo del compratore della vendita, in caso l'evento \verb|saleCompleted| esista, altrimenti ottiene il valore \verb|null|.
        \newline
        Alla riga 53 viene costruito l'oggetto \verb|saleData| contenente tutte le informazioni sulla vendita e sulle monete. Infine \verb|saleData| viene inserito nell'array \verb|salesList| e quest'ultimo viene restituito al chiamante.
        \newline
        In caso di errore nel blocco \verb|try|, la funzione restituisce una lista vuota.

        \subsubsection{saleAccept}
        \begin{lstlisting}[style=ES6, title={Funzione saleAccept}]
export const saleAccept = async (web3, accountAddress, saleAddress, coinsToAccept) => {
  try {
    for(let coin of coinsToAccept) {
      const {address: coinAddress, symbol, amount} = coin;

      const tokenInstance = new web3.eth.Contract(
        SMART_CONTRACTS.TKN_TMPLT_ABI,
        coinAddress,
      );

      await tokenInstance.methods.approve(saleAddress, amount).send({from: accountAddress, gasPrice: '0'});
    }

    const saleInstance = new web3.eth.Contract(
      SMART_CONTRACTS.SALE_TMPLT_ABI,
      saleAddress,
    );
    const res = await saleInstance.methods.acceptSale().send({from: accountAddress, gasPrice: '0'});
    return true;
  } catch(error) {
    for(let i = 0; i < coinsToAccept.length; i++) {
      const coinInstance = new web3.eth.Contract(
        SMART_CONTRACTS.TKN_TMPLT_ABI,
        coinsToAccept[i],
      );

      await coinInstance.methods.approve(saleAddress, 0).send({from: accountAddress, gasPrice: "0"});
    }
    return false;
  }
}\end{lstlisting}
        La funzione \verb|saleAccept| permette di accettare una vendita. Prende come parametri l'istanza di \verb|web3|, l'indirizzo del compratore, l'indirizzo della vendita e la lista delle monete accettate come pagamento per la vendita.
        \newline
        Per ogni moneta della lista passata come parametro vengono estratte le informazione di indirizzo della moneta, il simbolo della moneta e la quantità della moneta necessaria per accettare la vendita.
        Viene, poi, ottenuta l'istanza del token e viene chiamata la funzione \verb|approve| sull'istanza, passando come parametri l'indirizzo della vendita e la quantità della moneta. In questo modo il contratto della vendita ottiene il permesso
        di spendere la quantità di quella moneta.
        \newline
        Successivamente si ottiene l'istanza della vendita e su questa viene chiamato il metodo \verb|acceptSale()| che conclude l'accettazione della vendita. Viene, quindi, restituito il valore \verb|true| al chiamante.
        In caso di fallimento viene restituito, invece, \verb|false| e viene fatto il reset della \emph{allowance} del contratto della vendita a 0 per tutte le monete passate in input.

        \subsubsection{saleCancel}
        \begin{lstlisting}[style=ES6, title={Funzione saleCancel}]
export const saleCancel = async (web3, accountAddress, saleAddress) => {
try {
    const saleInstance = new web3.eth.Contract(
      SMART_CONTRACTS.SALE_TMPLT_ABI,
      saleAddress,
    );

    const res = await saleInstance.methods.cancelSale().send({from: accountAddress, gasPrice: '0'});
    return true;
  } catch(error) {
    return false;
  }
}\end{lstlisting}
        La funzione \verb|saleCancel| permette di cancellare una vendita. Prende in input l'istanza di \verb|web3|, l'indirizzo del proprietario della vendita e l'indirizzo della vendita da cancellare.
        Inizialmente viene ottenuta l'istanza della vendita e, successivamente, su di essa viene richiamata la funzione \verb|cancelSale()|. In caso di successo viene restituito \verb|true| altrimenti \verb|false|.

        \subsubsection{saleCancelBatch}
        \begin{lstlisting}[style=ES6, title={Funzione saleCancelBatch}]
export const saleCancelBatch = async (web3, accountAddress, saleAddresses) => {
  try {
    const SaleFactoryInstance = new web3.eth.Contract(
      SMART_CONTRACTS.SALE_FCTRY_ABI,
      SMART_CONTRACTS.SALE_FCTRY_ADDR,
    );

    const res = await SaleFactoryInstance.methods.cancelBatchSales(saleAddresses).send({from: accountAddress, gasPrice: '0'});
    return true;
  } catch(error) {
    return false;
  }
}\end{lstlisting}
        La funzione \verb|saleCancel| permette di cancellare multiple vendite. Prende in input l'istanza di \verb|web3|, l'indirizzo del proprietario delle vendite e la lista degli indirizzi delle vendite da cancellare.
        \newline
        Viene ottenuta l'istanza di \verb|saleFactory| e su questa viene richiamato il metodo \verb|cancelBatchSales| passando la lista delle vendite. In caso di successo viene restituito \verb|true|, altrimenti \verb|false|.

        \subsection{Pagina "Create Sale"}
        Il processo di creazione di una vendita è diviso in tre step.
        \begin{itemize}
          \item Nel primo step l'utente sceglie i token in suo possesso da mettere in vendita;
          \item Nel secondo step l'utente sceglie i token che accetta come pagamento per la vendita dei token scelti nel primo step;
          \item Nel terzo step viene mostrato all'utente un riassunto delle scelte fatte nei due step precedenti. In questo passo, inoltre, l'utente può
                impostare una data di scadenza della vendita.
        \end{itemize}
        In tutti e tre gli step sono presenti alcuni componenti grafici comuni, questi sono visibili nell'immagine \ref{fig:commonComponents}.
        \begin{figure}[H]
          \includegraphics[scale=0.6, fbox]{commonComponents.png}
          \centering
          \caption{Componenti comuni}
          \centering
          \label{fig:commonComponents}
        \end{figure}
        Per mostrare graficamente il progresso nei diversi step è presente, in cima alla pagina, un componente
        \verb|<stepper>|, questo, come mostrato nell'immagine \ref{fig:commonComponents} al punto 1, indica all'utente gli step terminati e quelli ancora da completare.
        \newline
        Al di sotto, al punto 2, sono presenti due pulsanti per la navigazione nei vari step. Il primo permette di tornare allo step 1 azzerando tutti i parametri inseriti.
        Il secondo serve per avanzare allo step successivo.
        \newline
        Al punto 3 è presente un campo di inserimento per cercare una moneta in particolare. Questo componente è presente solo nel primo e secondo step
        \subsubsection{Caricamento della pagina}
        Al caricamento della pagina vengono inizializzate alcune variabili, tra cui le più significative sono le seguenti:
        \begin{lstlisting}[style=ES6, title={Inizializzazione delle variabili al caricamento della pagina Create Sale}]
        const {web3Instance, userAccount} = props;
        const [coinsToSellAmounts,
               setCoinsToSellAmounts] = useState(new Map());
        const [coinsToAcceptAmounts,
               setCoinsToAcceptAmounts] = useState(new Map());
        const [coinsList, setCoinsList] = useState([]);
        const [activeCoinsList,
               setActiveCoinsList] = useState([]);
        const [activeStep, setActiveStep] = useState(0);\end{lstlisting}
        \verb|web3Instance| contiene l'istanza di web3 mentre \verb|userAccount| contiene l'indirizzo Ethereum dell'utente corrente, questi vengono passati alla pagina come props.
        \newline
        \verb|coinsToSellAmounts| e \verb|coinsToAcceptAmounts| sono variabili dotate di stato ed entrambi sono di tipo \verb|Map|, ossia un dizionario con chiavi di ricerca e valori associati.
        Vengono usate per mantenere le quantità delle monete scelte da mettere in vendita, per la prima variabile, oppure quelle da accettare come pagamento, nel caso della seconda variabile.
        Hanno come chiavi di ricerca le monete mentre i valori sono le quantità di queste.
        \newline
        \verb|coinList| è un array usato per contenere la lista di tutte le monete possedute dall'account utente.
        \newline
        \verb|activeCoinsList| è l'array preso come riferimento per mostrare graficamente la lista delle monete.
        \newline
        \verb|activeStep| è un numero intero che indica lo step corrente.
        \newline
        Le variabili di stato hanno, naturalmente, associate le funzioni per modificarne il loro valore.
        \newline
        Una volta caricata la pagina, con l'uso di \verb|useEffect()|, viene richiamata la funzione \verb|fetchCoins|.
        \begin{lstlisting}[style=ES6, title={Funzione fetchCoins}]
        const fetchCoins = async () => {
          setLoadingCoinList(true)
          const newCoinsList = await coinGetListOnlyOwned(
                               web3Instance,userAccount);
          setLoadingCoinList(false);
          setCoinsList(newCoinsList);
          setActiveCoinsList(newCoinsList);
        }\end{lstlisting}
        Questa funzione, chiamando la funzione \verb|coinGetListOnlyOwned()|, assegna a \verb|coinsList| e a \verb|activeCoinsList| la lista di tutte le monete che l'utente possiede,

        \subsubsection{Box di ricerca}
        \begin{lstlisting}[style=ES6, title={Funzione fetchCoins}]
        const handleSearch = (event) => {
          const searchInput = event.target.value.toLowerCase();
  
          setActiveCoinsList(coinsList.filter(coin => {
              const coinName = coin.name.toLowerCase();
              const coinSymbol = coin.symbol.toLowerCase();
              if(coinName.includes(searchInput) || 
                 coinSymbol.includes(searchInput)) return coin;
          }));
        }

        <TextField 
        id="searchBox"
        label="Search for a coin"
        variant="outlined"
        onChange={handleSearch}/> \end{lstlisting}
        Il box di ricerca è realizzato usando il componente \verb|<TextField>|, ad ogni inserimento/eliminazione di caratteri viene invocata la funzione \verb|handleSearch|.
        Questa funzione, come visibile alla riga 1, prende come parametro l'evento lanciato. Quest'ultimo contiene il testo presente nel \verb|<TextField>|,
        questo viene, quindi, convertito in caratteri minuscoli ed assegnato alla variabile \verb|searchInput|. Alla riga 4 viene chiamata la funzione filter sull'array \verb|coinsList|,
        questo metodo ritorna un nuovo array dopo aver filtrato gli elementi della lista secondo un certo criterio. In questo caso, il criterio, visibile alle righe 7 e 8,
        è che il nome o il simbolo della moneta che si sta controllando contenga la stringa da cercare contenuta in \verb|searchInput|. In caso positivo la moneta viene aggiunta all'array da ritornare.
        Una volta terminata la funzione di filtro si ha quindi una lista contenete solo monete che includono il termine di ricerca. Dopodiché questa lista viene assegnata alla variabile di stato \verb|activeCoinsList| usando,
        perciò, la funzione \verb|setActiveCoinsList()|. In questo modo verranno mostrate a video le monete filtrate. 

        \subsubsection{Step 1: scelta dei token da vendere}
        \begin{figure}[H]
          \includegraphics[scale=0.16]{coinsToSell.png}
          \centering
          \caption{Pagina per la scelta dei token in vendita}
          \centering
          \label{fig:selectCoinsToSell}
        \end{figure}
        La pagina, visibile in figura \ref{fig:selectCoinsToSell}, contiene un componente custom chiamato \verb|SelectCoins|, questo ha come props l'array \verb|activeCoinsList| e genera, usando il componente \verb|<List>|, una lista contenente tutte le monete della lista.
        \newline
        Ogni elemento della lista contiene le informazioni di un token all'interno di \verb|activeCoinsList| e un componente
        \verb|<TokenListItem>| contenente un componente \verb|<TextField>|. Quest'ultimo permette l'inserimento della quantità desiderata del token da mettere in vendita.
        \paragraph{Inserimento di una quantità di una moneta}
        \label{insertCoinsToSell}
        \begin{lstlisting}[style=ES6, title={Funzione handleAmountChange}]
const handleAmountChange = (coin, amount) => {
  const isInputEmpty = amount.length === 0;
  amount = parseInt(amount);

  if(isInputEmpty || amount === 0) {
    const newMap = new Map(coinsToSellAmounts);
    newMap.delete(coin);
    setCoinsToSellAmounts(newMap);
  } else {
    setCoinsToSellAmounts(prev => new Map(prev.set(coin, amount)));
  }

  if(amount > coin.balance) {
    setErrorsAmounts(prev => new Set(prev.add(coin)));
  } else {
    const newSet = new Set(errorsAmounts);
    newSet.delete(coin);
    setErrorsAmounts(newSet);
  }
}\end{lstlisting}
        All'inserimento della quantità di una moneta viene richiamata la funzione \verb|handleAmountChange(coin, amount)| passando, come parametri, la moneta interessata e la quantità inserita.
        \newline
        La funzione inizia assegnando alla variabile \verb|isInputEmpty| il valore \verb|true| in caso il parametro \verb|amount| sia una stringa vuota, \verb|false| altrimenti. Inoltre, siccome \verb|amount| è una stringa, converte questo in un valore intero.
        \newline
        Successivamente, in caso \verb|isInputEmpty| sia \verb|true| oppure \verb|amount| sia 0, viene eliminato da \verb|coinsToSellAmounts| la voce con chiave di ricerca \verb|coin|. Altrimenti inserisce, sempre in \verb|coinsToSellAmounts|, una voce con chiave \verb|coin| e valore \verb|amount|.
        In questo modo \verb|coinsToSellAmounts| contiene sempre le monete e le quantità associate inserite dall'utente.
        \newline
        La funzione, inoltre, controlla che la quantità inserita non ecceda la quantità posseduta dall'utente, ossia confronta \verb|amount| e il parametro \verb|balance| all'interno di \verb|coin|.
        \newline
        Nel caso di \verb|amount| maggiore di \verb|coin.balance|, cioè l'utente non possiede la quantità inserita, viene aggiunto a \verb|errorsAmounts| il valore l'oggetto \verb|coin|.
        Nel caso opposto viene eliminato \verb|coin| da \verb|errorsAmounts|. \verb|errorsAmounts| viene poi utilizzato, in caso di errore nell'inserimento di una quantità, per disabilitare il bottone per passare al prossimo step.
        Per far questo basta controllare che \verb|errorsAmounts| non sia vuoto.
        \paragraph{Quantità errata}
        \label{quantityerror}
        Il componente \verb|SelectCoins| ha una props chiamata \verb|showCoinError| a cui viene passato il riferimento ad una funzione chiamata \verb|showCoinError()|.
        \begin{lstlisting}[style=ES6, title={Funzione showCoinError}]
const showCoinError = (coin, balance) => {
  if(activeStep === 0) 
    if(coinsToSellAmounts.has(coin) && coinsToSellAmounts.get(coin) > balance)
      return true;
  return false;
}\end{lstlisting}
        Questa funzione prende in input due parametri: \verb|coin|, ossia una moneta, e \verb|balance|, la quantità di \verb|coin| che l'utente possiede. La funzione inizia controllando che l'attuale step sia lo 0,
        questo perché è solo nello step iniziale che possono presentarsi errori nell'inserimento di quantità. La funzione prosegue, quindi, controllando che \verb|coinsToSellAmounts| abbia l'oggetto \verb|coin|, e che il valore associato a \verb|coin| in \verb|coinsToSellAmounts| sia superiore a \verb|balance|.
        In questo caso vuol dire che l'utente ha inserito \verb|coin| tra le monete da vendere, ma ha inserito una quantita che non possiede, quindi la funzione restituisce \verb|true|.
        \begin{figure}[H]
          \includegraphics[scale=0.5, fbox]{errorMessage.png}
          \centering
          \caption{Sopra un inserimento di quantità errata, sotto un inserimento corretto}
          \centering
          \label{fig:errorMessage}
        \end{figure}
        Il componente \verb|<SelectCoins>| quando genera i vari \verb|<TokenListItem>| di ogni moneta, ossia i componenti che contengono i box di inserimento delle quantità, aggiunge loro una props \verb|showError| contenente la chiamata alla funzione \verb|showCoinError()|,
        passando la moneta e il bilancio della moneta.
        \begin{lstlisting}[style=ES6, title={Funzione showCoinError}]
  <TokenListItem 
  showError={props.showCoinError(coin, coin.balance)}
  ... 
  />
\end{lstlisting}
        Dove \verb|coin| è ottenuto facendo ciclo sull'array \verb|activeCoinsList|.
        \newline
        Ogni \verb|<TokenListItem>| ha un valore di tipo boolean all'interno della proprietà \verb|showError|. Questo viene usato per scegliere se mostrare la \verb|<TextField>| di inserimento con messaggio di errore oppure normale, come visibile in figura \ref{fig:errorMessage}.
\begin{lstlisting}[style=ES6, title={Scelta di TextField da mostrare}]
(props.showError) ?
<TextField error={true} helperText={errorMessage} .../>
:
<TextField .../>\end{lstlisting}
        \paragraph{Avanzamento al passo 2}
        Cliccando sul pulsante \verb|next|, oltre a passare al passo successivo, vengono effettuate le seguenti operazioni.
\begin{lstlisting}[style=ES6, title={Codice eseguito passando al passo 2}]
let newCoinsList = await coinGetListAll(web3Instance, userAccount);
const selectedCoins = Array.from(coinsToSellAmounts.keys());
newCoinsList = newCoinsList.filter(coin => {
    for(let c of selectedCoins) {
        if(c.address === coin.address) return false;
    }
    return true;
});
setLoadingCoinList(false);
setCoinsList(newCoinsList);
setActiveCoinsList(newCoinsList);\end{lstlisting}
        Questo codice genera un array \verb|newCoinsList| contenente tutte le monete tranne quelle che l'utente ha selezionato di vendere al passo 1. Questo array viene, quindi, assegnato a \verb|coinsList| e \verb|activeCoinsList|.

        \subsubsection{Step 2: scelta dei token da accettare}
        Il processo di scelta dei token da accettare come pagamento è molto simile a quello della scelta dei token da vendere del primo step. La principale differenza è l'array \verb|activeCoinsList| passato a \verb|SelectCoins|.
        Questo, infatti, nel passo 2 non contiene solo le monete possedute dall'utente, ma contiene tutte le monete tranne quelle che l'utente ha selezionato nello step 1.
        \newline
        Inoltre non è più necessario controllare la quantità inserita perché non c'è la restrizione del bilancio dell'utente, perciò il sistema descritto in \ref{quantityerror} non è applicato in questo step.
        Naturalmente la funzione \verb|handleAmountChange()|, richiamata ad ogni inserimento/modifica di una quantità, non modifica più \verb|coinsToSellAmounts|, come in \ref{insertCoinsToSell}, ma modifica \verb|coinsToAcceptAmounts|.

        \subsubsection{Step 3: riepilogo finale}
        \begin{figure}[H]
          \includegraphics[scale=0.16]{resume.png}
          \centering
          \caption{Pagina di riepilogo della creazione di una vendita}
          \centering
          \label{fig:resume}
        \end{figure}
        In questo step viene mostrato un riepilogo delle scelte fatte dall'utente nei due step precedenti. Questo sommario è implementato da un componente custom chiamato \verb|<ResumePage>| che contiene due componenti \verb|<List>|.
        I dati delle due liste sono passate a \verb|<ResumePage>| attraverso due sue props: \verb|coinsToSell| e \verb|coinsToAccept|. Al primo viene passato \verb|coinsToSellAmounts|, al secondo viene passato \verb|coinsToAcceptAmounts|.
        Siccome questi due sono \verb|Map|, prima di utilizzare i loro valori, \verb|<ResumePage>| deve convertirli in \verb|Array|, per fare ciò utilizza la funzione \verb|Array.from()| passando una \verb|Map|.
        Questa funzione restituisce una lista contenente tutte le voci, quindi le coppie chiave-valore, della \verb|Map| passata.
        \newline
        Il componente \verb|<ResumePage>| contiene, inoltre, un selettore di data, implementato con il componente \verb|<DateTimePicker>| fornito da \emph{MaterialUI}, e un pulsante per abilitarne o disabilitarne l'inserimento.
        La data inserita rappresenta la data di scadenza della vendita in corso di creazione, ovvero la data oltre la quale un utente non potrà più accettare la vendita. L'inserimento di una data modifica il valore della variabile di stato \verb|selectedExpirationDate| con il
        valore della data selezionata sotto forma di "\emph{unix timestamp}", ovvero la data viene rappresentata come i numeri di secondi passati dal 1° Gennaio 1970 (UTC).
        \paragraph{Creazione di una vendita}
        Premendo il pulsante "\emph{Create Sale}" viene richiamata la funzione \verb|createSale()|.
\begin{lstlisting}[style=ES6, title={Funzione createSale()}]
const createSale = async () => {
  const coinsToSellAddr = [];
  const coinsToSell = Array.from(coinsToSellAmounts.keys());
  for(let coin of coinsToSell) coinsToSellAddr.push(coin.address);

  const amountsToSell= Array.from(coinsToSellAmounts.values());

  const coinsToAcceptAddr = [];
  const coinsToAccept= Array.from(coinsToAcceptAmounts.keys());
  for(let coin of coinsToAccept) coinsToAcceptAddr.push(coin.address);

  const amountsToAccept = Array.from(coinsToAcceptAmounts.values());
  
  const saleAddr = await saleCreate(web3Instance, userAccount, coinsToSellAddr, amountsToSell, coinsToAcceptAddr, amountsToAccept, selectedExpirationDate);

  let creationMessage = saleAddr ? "Sale created successfully" : "Sale was not created. Something went wrong...";
              
  handleReset();
  
  setAlertState({
    result: saleAddr,
    creationMessage,
    open: true,
  });
}\end{lstlisting}
        La funzione, come visibile dalla riga 2 alla riga 6, costruisce due array a partire dal \verb|Map| \verb|coinsToSellAmounts|: \verb|coinsToSellAddr| e \verb|amountsToSell|.
        Il primo contiene gli indirizzi delle monete in vendita, il secondo contiene le quantità delle monete in vendita. Questa operazione viene ripetuta anche per \verb|coinsToAcceptAmounts|.
        Una volta creati gli array, viene richiamata la funzione \verb|saleCreate| contenuta nel file \verb|sale.js|. Vengono passati come parametri l'istanza di \verb|web3|, l'indirizzo dell'utente, l'array degli indirizzi delle monete in vendita,
        l'array delle quantità in vendita, l'array degli indirizzi delle monete da accettare, l'array delle quantità da accettare e la data di scadenza.
        In base al risultato della chiamata viene, quindi, mostrato un messaggio di risposta. Infine viene azzerata la pagina, tornando, perciò, allo step 1.

        \subsection{Pagina "Sales List"}
        \begin{figure}[H]
          \includegraphics[scale=0.16]{salesList.png}
          \centering
          \caption{Pagina con la lista delle vendita}
          \centering
          \label{fig:salesList}
        \end{figure}
        Questa pagina permette di visualizzare la lista di tutte le vendite. Inoltre, consente, utilizzando i pulsanti e il selettore in cima alla pagina, di filtrare le vendite secondo diversi parametri.
        Prima di mostrare le vendite, in caso l'utente possieda delle vendite scadute, la pagina mostra un \emph{pop-up} che elenca le monete e le loro quantità che l'utente può ottenere indietro.
        \subsubsection{Caricamento della pagina}
        \label{expiredSales}
        Le variabili più significative inizializzate al caricamento della pagina sono le seguenti.
\begin{lstlisting}[style=ES6, title={Variabili significative di "Sales List"}]
const [hasExpiredSales, setHasExpiredSales] = useState(false);
const [onGoingSalesList, setOnGoingSalesList] = useState([]);
const [endedSalesList, setEndedSalesList] = useState([]);
const [expiredSalesList, setExpiredSalesList] = useState([]);
const [showingSalesList, setShowingSalesList] = useState([]);
const [selectedFilter, setSelectedFilter] = useState(0);
const [isEndedStatusSelected, setIsEndedStatusSelected] = useState(false);
const [selectedSale, setSelectedSale] = useState();\end{lstlisting}
        Tutte queste variabili sono variabili con stato. \verb|hasExpiredSales| è un \verb|boolean| che indica la presenza di vendite scadute possedute dall'attuale utente. Le loro funzioni sono le seguenti.
        \newline
        \verb|onGoingSalesList| è un array che contiene le vendite ancora in corso, mentre \verb|endedSalesList| contiene tutte le vendite terminate, sia quelle accettate che quelle cancellate, e quelle scadute.
        Invece, \verb|expiredSalesList| contiene solo le vendite scadute.
        \verb|showingSalesList| è l'array contenente le vendite visualizzate a video. \verb|selectedFilter| indica il filtro attuale selezionato, mentre \verb|isEndedStatusSelected| indica se si è selezionato di mostrare solo le vendite terminate.
        \verb|selectedSale| contiene la vendita di cui mostrare le informazioni dettagliate.
        Al caricamento della pagina viene chiamata la funzione \verb|useEffect()| che, a sua volta, richiama la funzione \verb|fetchSales()|.
\begin{lstlisting}[style=ES6, title={Funzione fetchSales()}]
const fetchSales = async () => {
  setLoadingSaleList(true);
  const onGoingSales = [];
  const endedSales = [];
  const expiredSales = [];
  let ownerHasExpiredSales = false;
  let allSalesList = await saleGetAll(web3Instance, userAccount);
  
  for(let sale of allSalesList) {
    const isExpired = !sale.ended && sale.expiration !== '0' ? isAfter(new Date(), fromUnixTime(sale.expiration)) : false;

    sale.ended || isExpired ? endedSales.push(sale) : onGoingSales.push(sale);

    const isExpiredAndOwned = sale.owner === userAccount && isExpired;

    isExpiredAndOwned && expiredSales.push(sale);

    ownerHasExpiredSales = isExpiredAndOwned || ownerHasExpiredSales;
  }

  setOnGoingSalesList(onGoingSales);
  setEndedSalesList(endedSales);
  setExpiredSalesList(expiredSales);
  setHasExpiredSales(ownerHasExpiredSales);
  setShowingSalesList(onGoingSales);
  setLoadingSaleList(false);
}\end{lstlisting}
        Questa funzione genera inizialmente una variabile \verb|ownerHasExpiredSales| di tipo \verb|boolean| inizializzata a false, e tre array: \verb|onGoingSales|, \verb|endedSales| e \verb|expiredSales|.
        Viene assegnata, chiamando la funzione \verb|saleGetAll()|, alla variabile \verb|allSalesList| la lista di tutte le vendite. Per ogni vendita si controlla se è scaduta. Questa verifica, visibile alla riga 10, avviene controllando
        che la vendita non sia terminata e che la data di scadenza sia diversa da 0 e che l'attuale data sia successiva alla data di scadenza. Nel caso di vendita scaduta oppure terminata, questa viene inserita in \verb|endedSales|, altrimenti
        in \verb|onGoingSales|. Successivamente la funzione controlla se la vendita è scaduta ed è posseduta dall'utente, in questo caso la vendita viene inserita anche in \verb|expiredSales|. Viene poi aggiornato il valore di \verb|ownerHasExpiredSales|
        con il risultato dell'operazione "\emph{OR}" tra il vecchio valore della variabile e ed il controllo della vendita scaduta e posseduta dall'utente. Questa variabile, infatti, avrà valore \verb|true| se l'utente possiede almeno una vendita scaduta, \verb|false| altrimenti.
        Infine i tre array ed il valore boolean vengono assegnati alle rispettive variabili di stato.
        \subsubsection{Pop-up delle vendite scadute}
        \begin{figure}[H]
          \includegraphics[scale=0.5, fbox]{expiredSales.png}
          \centering
          \caption{Pop-up mostrato se l'utente ha vendite scadute}
          \centering
          \label{fig:Pop-up}
        \end{figure}
        Il pop-up in figura \ref{fig:Pop-up} viene visualizzato al caricamento della pagina nel caso l'utente abbia vendite scadute, ossia nel caso \verb|ownerHasExpiredSales|, il cui valore è stato calcolato in  \ref{expiredSales}, abbia valore \verb|true|.
        Il componente custom che realizza il pop-up è \verb|<SaleExpiredDialog>|. A questo viene passato attraverso la props \verb|expiredSales| l'array \verb|expiredSalesList|. Per realizzare la finestra di dialogo, \verb|<SaleExpiredDialog>| si basa sul componente
        \verb|<Dialog>| di \emph{Material-UI}. A quest'ultimo è stato inserito un titolo, una lista e un pulsante. Il titolo mostra all'utente il numero, ottenuto con la lunghezza dell'array passato nella props \verb|expiredSales|, di vendite scadute che possiede.
        La lista elenca le monete e le quantità associate che l'utente può richiedere come rimborso. L'utente ottiene il rimborso premendo il pulsante "\emph{Accept}".
        \paragraph{Calcolo del rimborso}
        Al caricamento del componente \verb|<SaleExpiredDialog>| viene richiamata la funzione \verb|calcRefund()|.
        \begin{lstlisting}[style=ES6, title={Funzione calcRefund()}]
const calcRefund = () => {
  const tmpRefundMap = new Map();

  for(let sale of expiredSales) {
    for(let coin of sale.tokensOnSaleData) {
      tmpRefundMap.get(coin.symbol) ?
        tmpRefundMap.set(
          coin.symbol,
          parseInt(tmpRefundMap.get(coin.symbol)) + parseInt(coin.amount))
        :
        tmpRefundMap.set(coin.symbol, coin.amount);
    }
  }

  setCoinsToRefund(Array.from(tmpRefundMap.entries()));
}\end{lstlisting}
        La funzione genera la \verb|Map| \verb|tmpRefundMap|, successivamente per ogni moneta in vendita di ogni vendita all'interno di \verb|expiredSales|, ossia l'array contenente le vendite scadute dell'utente, controlla se l'indirizzo della moneta è presente come chiave
        all'interno di \verb|tmpRefundMap|. Se non è presente inserisce il simbolo come chiave e il la quantità della moneta in vendita come valore associato. Altrimenti aggiunge la quantità al valore già presente.
        Alla fine delle iterazioni, \verb|tmpRefundMap| conterrà le monete e le loro quantità totali da rimborsare. Infine, \verb|tmpRefundMap| viene convertito in array e assegnato a \verb|coinsToRefund|, ossia l'array utilizzato dalla lista in \verb|SaleExpiredDialog|.
        \paragraph{Accettazione del rimborso}
        Premendo sul pulsante "\emph{Accept}" viene richiamata la funzione \verb|acceptRefund()|.
\begin{lstlisting}[style=ES6, title={Funzione acceptRefund()}]
const acceptRefund = async () => {
  const salesAddresses = [];

  for(let sale of expiredSales) {
    salesAddresses.push(sale.address);
  }

  const result = await saleCancelBatch(web3Instance, userAccount, salesAddresses);

  const alertMessage = result ? "Sales refunded successfully" : "Sales not refunded. Something went wrong...";

  setAlertState({
    result: result,
    message: alertMessage,
    open: true,
  });
  props.onClose();
}\end{lstlisting}
        La funzione crea un array chiamato \verb|salesAddresses| contenente tutti gli indirizzi delle vendite scadute contenute in \verb|expiredSales|. Questo array viene poi passato come parametro alla chiamata della funzione \verb|saleCancelBatch|.
        Viene, quindi, mostrato un messaggio che comunica all'utente il risultato dell'operazione e, infine, il pop-up viene chiuso.
        \subsubsection{Filtro delle vendite}
        \begin{figure}[ht]
          \includegraphics[scale=0.7, fbox]{saleFilter.png}
          \centering
          \caption{Filtro delle vendite}
          \centering
          \label{fig:salesFilter}
        \end{figure}
        L'utente può filtrare la lista delle vendite per visualizzarle tutte oppure solo quelle che possiede. Per entrambi possono essere visualizzate quelle in corso oppure quelle terminate.
        Il filtro è composto da due pulsanti, realizzati con due \verb|<ToggleButton>| contenuti all'interno di un \verb|<ToggleButtonGroup>|, entrambi i componenti forniti da \emph{Material-UI}. Questi componenti permettono che, alla pressione di un pulsante, venga graficamente selezionato il pulsante selezionato e vengano deselezionati gli altri.
        Il filtro è composto, inoltre, da un selettore, realizzato con il componente \emph{Material-UI} \verb|<Select>| contenente due \verb|<MenuItem>| che rappresentano le due opzioni possibili.
        Premendo un \verb|<ToggleButton>| viene richiamata la funzione \verb|handleChangeFilter()|.
\begin{lstlisting}[style=ES6, title={Funzione handleChangeFilter()}]
const handleChangeFilter = (event, filter) => {
  if(filter !== null) { 
    setSelectedFilter(filter);

    changeShowingSales(filter, isEndedStatusSelected);
    }
}\end{lstlisting}
        La funzione ha come parametro \verb|filter| che rappresenta l'indice del filtro selezionato, questo viene assegnato alla variabile \verb|selectedFilter|.
        Viene infine chiamato il metodo \verb|changeShowingSales()| passando il parametro \verb|filter| e la variabile \verb|isEndedStatusSelected|.
        \newline
        Selezionando, invece, un'opzione di \verb|<Select>| viene chiamata la funzione \verb|handleSalesStatusSelection()|.
\begin{lstlisting}[style=ES6, title={Funzione handleSalesStatusSelection()}]
const handleSalesStatusSelection = (status) => {
  setLoadingSaleList(true);
  const statusEnded = status === "Ended" ? true : false;
  setIsEndedStatusSelected(statusEnded);
  changeShowingSales(selectedFilter, statusEnded);
  setLoadingSaleList(false);
}\end{lstlisting}
        Questa funzione prende come parametro \verb|status| che è una stringa che contiene il valore "\emph{On going}" se è stato selezionato di visualizzare le vendite in corso, "\emph{Ended}" altrimenti.
        Viene assegnato a \verb|isEndedStatusSelected| il valore \verb|true| se \verb|status| ha valore "\emph{Ended}", altrimenti il valore \verb|false|. Infine, anche questa funzione richiama \verb|changeShowingSales()| passando
        \verb|selectedFilter| e il valore assegnato a \verb|isEndedStatusSelected|.
        Entrambe le funzioni descritte utilizzano il metodo \verb|changeShowingSales()|, questo ha il compito di cambiare, in base ai filtri, la lista visualizzata dall'utente.
\begin{lstlisting}[style=ES6, title={Funzione changeShowingSales()}]
const changeShowingSales = (selectedFilter, salesStatus) => {
  setLoadingSaleList(true);

  const toFilterList = salesStatus ? endedSalesList : onGoingSalesList;

  if(selectedFilter === 0) {
    setShowingSalesList(toFilterList);
  }

  if(selectedFilter === 1) {
    const filteredSales = toFilterList.filter((sale) => {
      if(sale.owner === userAccount) return true;
      return false;
    });

    setShowingSalesList(filteredSales);
  }

  setLoadingSaleList(false);
}\end{lstlisting}
        \verb|changeShowingSales()| ha due parametri: \verb|selectedFilter|, ossia il filtro selezionato, e \verb|salesStatus|, ossia lo stato delle vendite selezionato.
        In base al valore di \verb|salesStatus|, viene assegnato all'array \verb|toFilterList| la lista \verb|endedSalesList|, se si vuole visualizzare le vendite terminate, altrimenti \verb|onGoingSalesList|.
        In caso di \verb|selectedFilter| con valore 0, ossia è stato selezionato di visualizzare tutte le vendite, viene assegnato \verb|toFilterList| a \verb|showingSalesList|. Altrimenti, se ha valore 1, vengono filtrate le vendite in \verb|toFilterList|
        assegnando a \verb|setShowingSalesList| solo quelle possedute dall'utente.
        \subsubsection{Rappresentazione grafica di una vendita}
        \label{moreInfo}
        \begin{figure}[H]
          \includegraphics[scale=0.7, fbox]{sale.png}
          \centering
          \caption{Informazioni di base di una vendita}
          \centering
          \label{fig:sale}
        \end{figure}
        Nell'immagine \ref{fig:sale} è rappresentata l'interfaccia di una vendita della lista presente nella pagina "\emph{Sales List}". Questa presenta alcune informazioni di base della vendita.
        Al punto 1 è illustrata un'immagine stock in tema di criptomonete. Al punto 2 è presente il nome del proprietario della vendita, questa funzionalità è ancora incompleta in quanto è prima necessaria l'integrazione con l'applicazione di CommonsHood.
        Al punto 3 sono rappresentate, nella colonna a sinistra, le monete in vendita e, nella colonna a destra, le monete accettate come pagamento dalla vendita. Infine al punto 4 è presente un pulsante che, alla pressione, apre una finestra di dialogo in cui l'utente può interagire con la vendita.
        \subsubsection{Finestra di dialogo di una vendita}
        \begin{figure}[H]
          \includegraphics[scale=0.5, fbox]{saleInfo.png}
          \centering
          \caption{Informazioni di base di una vendita}
          \centering
          \label{fig:sale}
        \end{figure}
        Come descritto in \ref{moreInfo}, premendo il pulsante "\emph{More Info}" di una vendita viene aperta una finestra di dialogo. Questa mostra maggiori informazioni sulla vendita. Le informazioni visualizzate sono: il nome del venditore, che, come descritto in \ref{moreInfo}, non è ancora implementato;
        l'indirizzo della vendita, lo stato della vendita e la data di scadenza della vendita. La finestra contiene, inoltre, le liste delle monete in vendita e quelle come pagamento e le loro quantità. In fondo sono presenti due pulsanti. Il primo, colorato di rosso, permette all'utente di eliminare la vendita.
        Questo pulsante non viene mostrato in caso la vendita non appartenga all'utente. Il secondo pulsante, colorato di verde, permette all'utente di accettare la vendita. Questo è disabilitato in caso la vendita appartenga all'utente oppure in caso l'utente non abbia abbastanza monete per il pagamento.
        In caso la vendita sia già terminata, entrambi i pulsanti non vengono visualizzati.
        \paragraph{Eliminazione della vendita}
        Premendo il pulsante di eliminazione della vendita viene chiamata la funzione \verb|handleCancelSale()|.
\begin{lstlisting}[style=ES6, title={Funzione handleCancelSale()}]
const handleCancelSale = async () => {
  const cancelResult = await saleCancel(web3Instance, userAccount, saleAddress);

  const cancelMessage = cancelResult ? "Sale cancelled successfully" : "Sale was not cancelled. Something went wrong...";

  setAlertState({
    result: cancelResult,
    message: cancelMessage,
    open: true,
  })

  props.onSaleOperation();

  setShouldClose(true);
}\end{lstlisting}
        La funzione richiama il metodo \verb|saleCancel()| passando \verb|saleAddress|, ossia l'indirizzo della vendita, come parametro. Successivamente mostra un messaggio di risposta all'utente ed infine chiude la finestra di dialogo.
        \paragraph{Accettazione della vendita}
        Premendo il pulsante per accettre la vendita viene chiamata la funzione \verb|handleAcceptSale()|.
\begin{lstlisting}[style=ES6, title={Funzione handleAcceptSale()}]
const handleAcceptSale = async () => {
  const acceptResult = await saleAccept(web3Instance, userAccount, saleAddress, coinsToAccept);

  const acceptMessage = acceptResult ? "Sale accepted successfully" : "Sale was not accepted. Something went wrong...";

  console.log("SALE ACCEPT: ", acceptResult);
  setAlertState({
    result: acceptResult,
    message: acceptMessage,
    open: true,
  });

  props.onSaleOperation();

  setShouldClose(true);
}\end{lstlisting}
        La funzione esegue la chiamata al metodo \verb|saleAccept()|, funzione importata dal file \verb|sale.js|, passando come parametri \verb|saleAddress|, ossia l'indirizzo della vendita, e \verb|coinsToAccept|, ovvero la lista delle monete che la vendita necessita come pagamento.
        Infine mostra all'utente il risultato dell'accettazione e chiude la finestra.

        \newpage
        \section{Conclusioni}
        In questa tesi è stato sviluppato un sistema decentralizzato per lo scambio di token crittografici, chiamate anche criptomonete, tra gli utenti della piattaforma Commmonshood. Questo sistema è stato costruito implementando
        due smart contract, uno con il ruolo di "fabbrica" e l'altro di "prodotto", scritti con il linguaggio Solidity. Questi contratti hanno il compito di gestire gli eventi di creazione, eliminazione e accettazione di vendite in cui vengono offerte delle monete in cambio di altre.
        Per verificare il corretto funzionamento degli smart contract sono stati sviluppati dei file di test che controllano il comportamento dei contratti in diverse situazioni. Per eseguire i test è stato utilizzato \emph{Truffle}. Passati i test, sono stati fatti i deploy degli smart contract
        su una blockchain locale di test creata con \emph{Ganache}.
        Successivamente è stato sviluppato un'applicazione web, a partire da un boilerplate, che implementa le funzionalità delle vendite. La web app, sviluppata con il framework \emph{ReactJS} e con i componenti grafici della libreria \emph{Material-UI}, ha due pagine in cui sono divise le funzioni
        di creazione, eliminazione e accettazione delle vendite. Per connettere l'app ai contratti all'interno della blockchain locale, viene utilizzato \emph{Metamask}. Siccome gli smart contracts sono implementati all'interno di una blockchain locale di prova e l'applicazione web sviluppata è separata dalla
        piattaforma di CommonsHood, il prossimo obiettivo nello sviluppo futuro è quello di integrare il lavoro di questa tesi all'interno della piattaforma principale di CommonsHood.
        \newpage
        Vorrei, infine, dedicare una pagina per ringraziare tutte le persone che mi hanno permesso di raggiungere questo traguardo.
        \\
        \\
        Inanzitutto ringrazio il mio relatore, il Professore Claudio Schifanella, che mi ha guidato per tutto il periodo dello stage e della scrittura della tesi, e che mi ha dato l'opportunità
        di conoscere questo nuovo ambito. Ringrazio per la pazienza che mi ha dedicato a rispondere a tutti i miei dubbi e a spiegarmi tutti i concetti.
        \\
        \\
        Vorrei poi, inoltre, ringraziare i miei genitori e mia sorella Giada che mi hanno spronato nell'intraprendere il percorso universitario e che mi hanno sempre supportato in tutto questo tempo.
        \\
        \\
        Infine un grande ringraziamento ai miei colleghi di corso, ma soprattutto amici: Giulia, Michela, Nicolò e Sandro, che sono sempre stati con me in questo percorso durato 3 anni e con loro ho condiviso le depressioni pre-esami e le gioie post-esami.
        Grazie a loro ho passato un bellissimo triennio pieno di ricordi divertenti e felici. Ancora mi incapacito di come abbiano sopportato i miei molteplici lati negativi per questo lungo tempo.  Quindi, nuovamente, per tutto questo e altro ancora, \textbf{\emph{Grazie}}.

        \newpage
        \printbibliography
\end{document}